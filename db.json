{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/cactus/source/css/rtl.styl","path":"css/rtl.styl","modified":0,"renderable":1},{"_id":"themes/cactus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/clipboard/clipboard.min.js","path":"lib/clipboard/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","path":"lib/meslo-LG/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","path":"lib/meslo-LG/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","path":"lib/meslo-LG/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","path":"lib/meslo-LG/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","path":"lib/meslo-LG/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","path":"lib/meslo-LG/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","path":"lib/meslo-LG/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","path":"lib/meslo-LG/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","path":"lib/vazir-font/Vazir-Black.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","path":"lib/meslo-LG/MesloLGS-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","path":"lib/vazir-font/Vazir-Black.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","path":"lib/vazir-font/Vazir-Black.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","path":"lib/vazir-font/Vazir-Black.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","path":"lib/vazir-font/Vazir-Bold.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","path":"lib/vazir-font/Vazir-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","path":"lib/vazir-font/Vazir-Bold.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","path":"lib/vazir-font/Vazir-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","path":"lib/vazir-font/Vazir-Light.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","path":"lib/vazir-font/Vazir-Light.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","path":"lib/vazir-font/Vazir-Light.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","path":"lib/vazir-font/Vazir-Medium.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","path":"lib/vazir-font/Vazir-Light.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","path":"lib/vazir-font/Vazir-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","path":"lib/vazir-font/Vazir-Medium.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.eot","path":"lib/vazir-font/Vazir-Regular.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","path":"lib/vazir-font/Vazir-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.ttf","path":"lib/vazir-font/Vazir-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff","path":"lib/vazir-font/Vazir-Regular.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","path":"lib/vazir-font/Vazir-Thin.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff2","path":"lib/vazir-font/Vazir-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","path":"lib/vazir-font/Vazir-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","path":"lib/vazir-font/Vazir-Thin.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","path":"lib/vazir-font/Vazir-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.eot","path":"lib/vazir-font/Vazir-Variable.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.ttf","path":"lib/vazir-font/Vazir-Variable.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff","path":"lib/vazir-font/Vazir-Variable.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff2","path":"lib/vazir-font/Vazir-Variable.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","path":"lib/vazir-font/font-face.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.woff2","path":"lib/font-awesome/webfonts/fa-v4compatibility.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.ttf","path":"lib/font-awesome/webfonts/fa-v4compatibility.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","path":"lib/justified-gallery/css/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/js/jquery.justifiedGallery.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"6ab47147d4d30c30b6026a4fcff459c2c9866bb6","modified":1681550952390},{"_id":"source/_posts/test.md","hash":"4b34ba0626b6ab91f94ec401872479d16c8f5423","modified":1679761243431},{"_id":"themes/cactus/.gitignore","hash":"044711463cfff978c57dbe9612deeb221269890e","modified":1679761070924},{"_id":"themes/cactus/.jshintrc","hash":"d6ee46102ed2ff00acb555557f47241b701e99a4","modified":1679761070924},{"_id":"themes/cactus/_config.yml","hash":"6b69a8c0a05b42ed7d1d1a4755780133a1cded80","modified":1679761070927},{"_id":"themes/cactus/README.md","hash":"fba95d64ea7570473eca706931365db14f84a669","modified":1679761070925},{"_id":"themes/cactus/languages/ar.yml","hash":"2f1258875dbffa89d192a1d6481c4bd3c337126b","modified":1679761070928},{"_id":"themes/cactus/package.json","hash":"6d7ba55b4acf22dee9e2cd58798e10e8f33a1b21","modified":1679761070937},{"_id":"themes/cactus/gulpfile.js","hash":"944fa9b6fdbeb077746db572b757e031b40ae694","modified":1679761070927},{"_id":"themes/cactus/LICENSE","hash":"06806c75801c9ae870a1b47d588ef8e00d3c7c94","modified":1679761070925},{"_id":"themes/cactus/languages/ca.yml","hash":"6f9897fe8c7b7bf23be7fa58c530602217aea898","modified":1679761070928},{"_id":"themes/cactus/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1679761070929},{"_id":"themes/cactus/languages/de.yml","hash":"0734bfc33861585a12327142bf52489c882ad34f","modified":1679761070928},{"_id":"themes/cactus/.stylintrc","hash":"8bbbee5eae70fbe7dd53c9ce43d244b47d58385b","modified":1679761070925},{"_id":"themes/cactus/languages/es.yml","hash":"56ddfd9081641c45272bdc2df750e41ab8b600bf","modified":1679761070929},{"_id":"themes/cactus/languages/en.yml","hash":"491c87ff300815df52220f6cead8e28edea129df","modified":1679761070929},{"_id":"themes/cactus/languages/fa.yml","hash":"05fb8dad765af2b9eec32582f5d277eb2735ffc3","modified":1679761070930},{"_id":"themes/cactus/languages/kr.yml","hash":"ab5be04a1b4c4d87e164b1a045e220f855e85a38","modified":1679761070930},{"_id":"themes/cactus/languages/nl.yml","hash":"4c36921322e782775ccff9aec78d4261153cf5e5","modified":1679761070931},{"_id":"themes/cactus/languages/ru.yml","hash":"47fb1672f36d5adadf2f6c3a5c4d1714f5bd563b","modified":1679761070932},{"_id":"themes/cactus/languages/pl.yml","hash":"3677b782edd98986bb82568c6ff6c8b77140b75a","modified":1679761070931},{"_id":"themes/cactus/languages/fr.yml","hash":"4604fc8f94d98f6d53c80535fbae78814f88f32d","modified":1679761070930},{"_id":"themes/cactus/languages/pt-br.yml","hash":"417d25e3dae260a2503ec6a8f1b590fa00534b14","modified":1679761070931},{"_id":"themes/cactus/languages/it.yml","hash":"501bfc9aed86964ee75354a805378740a02af799","modified":1679761070930},{"_id":"themes/cactus/languages/tr.yml","hash":"7971cbff7f90ffe1dc40402be6332890be1ed2c7","modified":1679761070932},{"_id":"themes/cactus/layout/404.ejs","hash":"c04829c5ddc417d0b9a66cad55a838cc7eed997b","modified":1679761070934},{"_id":"themes/cactus/languages/zh-TW.yml","hash":"d02ac645f87c5841ff35499818654df85bd872f5","modified":1679761070933},{"_id":"themes/cactus/layout/archive.ejs","hash":"7ca8ba16a68a8831f32fce5dd8c9b720ec6465cb","modified":1679761070937},{"_id":"themes/cactus/scripts/cdn.js","hash":"6037ad2ddbdc4d87195d91b3bd9f197c1b40467a","modified":1679761070937},{"_id":"themes/cactus/languages/vi.yml","hash":"1a1dfc60e952c3429c038f69a9e0ca2057784fca","modified":1679761070933},{"_id":"themes/cactus/scripts/error_404.js","hash":"099d428e1b96b9c219a789da60b87703c509b2bb","modified":1679761070937},{"_id":"themes/cactus/layout/index.ejs","hash":"d79eb1fa8c5b84f1b2697e877c192297e1a4b70d","modified":1679761070937},{"_id":"themes/cactus/layout/layout.ejs","hash":"e14f83a23128ce0d4208f04f419363fd7d0cab18","modified":1679761070937},{"_id":"themes/cactus/scripts/merge-configs.js","hash":"98b79403945fa7f8dc177e6da283681677d02567","modified":1679761070937},{"_id":"themes/cactus/layout/post.ejs","hash":"48bf7c2ef2477dc58e49488d7612e88d8235bb48","modified":1679761070937},{"_id":"themes/cactus/scripts/meta.js","hash":"96b1a52af341adc741a5581ddc7335105abe780e","modified":1679761070937},{"_id":"themes/cactus/scripts/thumbnail.js","hash":"3d841aa267026703a5cc29f4ffbb613f0a2bbd45","modified":1679761070937},{"_id":"themes/cactus/layout/page.ejs","hash":"1700d4f434170e1eeb0e2a9470fc3c0732b2ba7e","modified":1679761070937},{"_id":"themes/cactus/layout/_partial/comments.ejs","hash":"162fb8592903605789f516be2cd9c678a1a2d207","modified":1679761070934},{"_id":"themes/cactus/languages/zh-CN.yml","hash":"d163690e48de5cf03914d69a99462d72eb040ad3","modified":1679761070933},{"_id":"themes/cactus/layout/_partial/head.ejs","hash":"6f22467a3ebf4151f0436ffd5be422437111b5ec","modified":1679761070935},{"_id":"themes/cactus/layout/_partial/footer.ejs","hash":"2336c1eb473fea860f4c3e309c50bc32544d0b4e","modified":1679761070935},{"_id":"themes/cactus/layout/_partial/header.ejs","hash":"7c410cd80fdf3f6167f2e25c9877cc51f3635772","modified":1679761070935},{"_id":"themes/cactus/layout/_partial/scripts.ejs","hash":"b1552398c9b838e772a144e99f92a53eca59e60f","modified":1679761070937},{"_id":"themes/cactus/layout/_partial/styles.ejs","hash":"42fd45758d8f8e814bfdd8b26eb676d87b8465b2","modified":1679761070937},{"_id":"themes/cactus/scripts/page_title.js","hash":"03b5c8b6215f0b305327e8d9b5d49add83b4b95f","modified":1679761070937},{"_id":"themes/cactus/source/css/_extend.styl","hash":"1b9b2c69b894343068f3384000581a6092c4e868","modified":1679761070937},{"_id":"themes/cactus/layout/_partial/search.ejs","hash":"12dba799ae5736dfbf1548e1923bbb7447de8a6d","modified":1679761070937},{"_id":"themes/cactus/source/css/_fonts.styl","hash":"5c1727836f5d6076a65cf91dbbeaba8d16b5132b","modified":1679761070937},{"_id":"themes/cactus/source/css/_mixins.styl","hash":"37093d2a554283ab652b59e5e0ff9b542edced0f","modified":1679761070965},{"_id":"themes/cactus/source/css/_variables.styl","hash":"5dcbf89bd23d9dd3c45d07049a1448b0ae95426b","modified":1679761070965},{"_id":"themes/cactus/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1679761070965},{"_id":"themes/cactus/source/css/rtl.styl","hash":"105284f992de848968d818f6200d2ebbdd5342d0","modified":1679761070965},{"_id":"themes/cactus/layout/_partial/pagination.ejs","hash":"f561e68e9dd10ae1cf2e79e8425f7e9b86ed723e","modified":1679761070936},{"_id":"themes/cactus/source/css/style.styl","hash":"60cef565fc2c7472445ec8da660ac310769167b2","modified":1679761070965},{"_id":"themes/cactus/source/css/_util.styl","hash":"1c7bed7376f04d7b77d817e132aee08cf65e6395","modified":1679761070965},{"_id":"themes/cactus/source/js/main.js","hash":"adc9e8e86e82f6bce527d5674df0a9b298ac71a0","modified":1679761070980},{"_id":"themes/cactus/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1679761070965},{"_id":"themes/cactus/layout/_partial/post/actions_mobile.ejs","hash":"c8d06799755147a64cdd0cb2728d3ce46a044dae","modified":1679761070936},{"_id":"themes/cactus/source/js/search.js","hash":"0d2933fa97c4036805011cc219fcc43ae578e230","modified":1679761070980},{"_id":"themes/cactus/layout/_partial/post/actions_desktop.ejs","hash":"4b73c5ac831a36aea1d2743af57a54dde3509c6a","modified":1679761070936},{"_id":"themes/cactus/layout/_partial/post/date.ejs","hash":"bb624f77d29594b8d3a7dd82f1aee6eead6b9b61","modified":1679761070937},{"_id":"themes/cactus/layout/_partial/post/category.ejs","hash":"75567a2de037857cb3e4c9fc5fc87094a23fb119","modified":1679761070937},{"_id":"themes/cactus/layout/_partial/post/gallery.ejs","hash":"725ab823c2fb4a5e444eca3afa617d88f305ef71","modified":1679761070937},{"_id":"themes/cactus/layout/_partial/post/share.ejs","hash":"9c8eb57164e63d8563966ab901957c095ea60038","modified":1679761070937},{"_id":"themes/cactus/source/css/_colors/classic.styl","hash":"3d6c91b03ade77daf1ceb11c5dad48b0e35ac353","modified":1679761070937},{"_id":"themes/cactus/layout/_partial/post/tag.ejs","hash":"98fe03d5a8835dbc22869d519cc5b5f48808b1e5","modified":1679761070937},{"_id":"themes/cactus/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1679761070965},{"_id":"themes/cactus/layout/_partial/post/title.ejs","hash":"67da1757316408a72393e6d2aab4ec635e1d30c1","modified":1679761070937},{"_id":"themes/cactus/source/css/_colors/white.styl","hash":"a20de63c1cd7ccf25b8313e2d211866a20e86fbe","modified":1679761070937},{"_id":"themes/cactus/source/css/_colors/dark.styl","hash":"d2978cb0035ba1da0a58db2ed947a72b0bd41042","modified":1679761070937},{"_id":"themes/cactus/source/css/_colors/light.styl","hash":"9b156c15c855677a50c4a27de17a8cb377b69802","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/arduino-light.styl","hash":"591962bfc758a521b4cb907750c19a1a2423b4d5","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/agate.styl","hash":"fc289ba8f47ead6331ec3a51533cfa93251c5634","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/arta.styl","hash":"262167aaebcf28de7f85af7ac77a76fa1fa284f7","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-dark.styl","hash":"7e83c7f2acaaaa98864660afe2794745c36c8e51","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-dark.styl","hash":"68584ed0e99c7d0e49ef8a2e67cd4dcdad359de4","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/androidstudio.styl","hash":"4d67bdab6cc9c614486ca42f98199a04d053e7f0","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-light.styl","hash":"f47de0b9d66617728f68096ed48371dd6bb9e67a","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-light.styl","hash":"657fe215931fd06e21b56374df699a94890f7ab4","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-dark.styl","hash":"1cecd13e0d6b24042ff86372f0596c1441bb834a","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/ascetic.styl","hash":"ca087a3c70998c7ac6b0b42d5cf7a653b8707591","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-light.styl","hash":"2b416a0567a53aa0fa8898b196ddd44315c1a5f3","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-dark.styl","hash":"a741eba35cdfe2cfd67dfbf109655f253d6b4795","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-light.styl","hash":"8d7c7242974aa2454fa792c5d7a47c5f9632355a","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-light.styl","hash":"c1db353e8613607580d40b12ddc162d029560576","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"802979cea895a0a384645cb30a43de9572cb0e3f","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-light.styl","hash":"8659eaae6a0c2e00b4b9199803e50adf4ff0128d","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-dark.styl","hash":"0d51ddc580ccb0a291271fa9632bc91dab632df6","modified":1679761070952},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-dark.styl","hash":"f186b357dcebded89b7bcc77389b2cff76533d72","modified":1679761070937},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-light.styl","hash":"96181544eeadc5b0749229f11607e7c01f81e078","modified":1679761070952},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-dark.styl","hash":"bbad7a9512b4873294e73ce806e36e43973e6ed8","modified":1679761070953},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-light.styl","hash":"8a5207a0c30262a0bf5e1a41411a306f7a89a7e7","modified":1679761070953},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"18dcb00ab9c62eb810d492047214331c51bb654f","modified":1679761070954},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-dark.styl","hash":"2f008271299042f2443bca98c9bcadbc8c45e837","modified":1679761070954},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"add3d88c9d12567dcfae7a8e49984d119fc72227","modified":1679761070955},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-light.styl","hash":"08e2df313c272d5c70c93e713639663c168180d0","modified":1679761070954},{"_id":"themes/cactus/source/css/_highlight/brown-paper.styl","hash":"d14846542a26b75fd26df5b5df6c5493733f73f6","modified":1679761070955},{"_id":"themes/cactus/source/css/_highlight/color-brewer.styl","hash":"9c4905eab730d0b389e6972e907057577f7e25f1","modified":1679761070956},{"_id":"themes/cactus/source/css/_highlight/codepen-embed.styl","hash":"1de45e603e2c71c7f6b0c1372a3ba00b1bc153a8","modified":1679761070956},{"_id":"themes/cactus/source/css/_highlight/dark.styl","hash":"98d7884806838a0b46132d759d60ac27c0c4bd9c","modified":1679761070956},{"_id":"themes/cactus/source/css/_highlight/darkula.styl","hash":"8965ad6920601c275ca97e617beff5536925a266","modified":1679761070957},{"_id":"themes/cactus/source/css/_highlight/docco.styl","hash":"7bd3389ce16d20488ab336d557056cc703c921c7","modified":1679761070957},{"_id":"themes/cactus/source/css/_highlight/far.styl","hash":"8da83d66724f2ce508a40f21b4f6dc0d704be562","modified":1679761070957},{"_id":"themes/cactus/source/css/_highlight/foundation.styl","hash":"28c59a31467c33bd51cbf3b6085782c2a724ff6c","modified":1679761070958},{"_id":"themes/cactus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1679761070955},{"_id":"themes/cactus/source/css/_highlight/github-gist.styl","hash":"71f4b0fca91a587e6eba15a5306dca963bb8f441","modified":1679761070958},{"_id":"themes/cactus/source/css/_highlight/googlecode.styl","hash":"7f5082ae008925a23eb713f160773fe647eb3ff7","modified":1679761070959},{"_id":"themes/cactus/source/css/_highlight/github.styl","hash":"a84eb710b302006120c3e7f8ca18f9e6fbc231c3","modified":1679761070958},{"_id":"themes/cactus/source/css/_highlight/grayscale.styl","hash":"c83804abe39faebd80f8f4ff64fbd7137674cb1c","modified":1679761070959},{"_id":"themes/cactus/source/css/_highlight/gruvbox-dark.styl","hash":"f66403ce77dcb16b1f98a5061b72f7581630d69f","modified":1679761070959},{"_id":"themes/cactus/source/css/_highlight/highlightjs.styl","hash":"fd796a58c5d4590cda67c998187933788d45f30a","modified":1679761070960},{"_id":"themes/cactus/source/css/_highlight/hopscotch.styl","hash":"dd3c78c42d4a865f11623235e5e5f6829d789706","modified":1679761070960},{"_id":"themes/cactus/source/css/_highlight/index.styl","hash":"36c44375229613a5bb9ee84a8e90214978070439","modified":1679761070961},{"_id":"themes/cactus/source/css/_highlight/hybrid.styl","hash":"4906456025787de04b48a87c42bb704c5ff67065","modified":1679761070960},{"_id":"themes/cactus/source/css/_highlight/ir-black.styl","hash":"aa31b30069ebee39e2c3ebb75e2c96ba8678eb14","modified":1679761070961},{"_id":"themes/cactus/source/css/_highlight/idea.styl","hash":"e284c1760e8da0848f56cd5601d867ceeb0192d7","modified":1679761070961},{"_id":"themes/cactus/source/css/_highlight/kimbie.dark.styl","hash":"3b998c640eeb2c6192fee24bc78b4137de475dd7","modified":1679761070962},{"_id":"themes/cactus/source/css/_highlight/kimbie.light.styl","hash":"e901738455ec9a1bddde7b62bbd8595de6033e1e","modified":1679761070962},{"_id":"themes/cactus/source/css/_highlight/kimbie.styl","hash":"13113af220dfed09cb49d85102babb352c3eff97","modified":1679761070962},{"_id":"themes/cactus/source/css/_highlight/monokai-sublime.styl","hash":"84a27bd29d939105d65f4164c219d6cc2e09ae60","modified":1679761070963},{"_id":"themes/cactus/source/css/_highlight/mono-blue.styl","hash":"14fb8678739b77f35771b6d63101ddbf1e7a9fbc","modified":1679761070963},{"_id":"themes/cactus/source/css/_highlight/monokai.styl","hash":"c3a3bfae1eb864505fbc8748db734600057af1af","modified":1679761070963},{"_id":"themes/cactus/source/css/_highlight/magula.styl","hash":"ab179306c12a1cf2949482beaca328e379ef034a","modified":1679761070962},{"_id":"themes/cactus/source/css/_highlight/obsidian.styl","hash":"efba069860181d2b709e1548dd16cf102ca267fa","modified":1679761070964},{"_id":"themes/cactus/source/css/_highlight/paraiso-dark.styl","hash":"50f1cee8a5b3b165b4184ead0a99dc564b62ef4f","modified":1679761070964},{"_id":"themes/cactus/source/css/_highlight/paraiso-light.styl","hash":"e428e8202b01e83b0f018a96058d806e7f4c76bf","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/pojoaque.styl","hash":"4d4a9360c35f3c5a0c5b9b49a1f2284e7e21317b","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/railscasts.styl","hash":"5dc9ce33cecee87fe9ca8f2ed9342602194484ec","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/paraiso.styl","hash":"846a06a57fa0b3db7f83ec7ac2bf34911f32cf66","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/rainbow.styl","hash":"95246afef181bd96f9adb1a2e84fb3ef302d4598","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/school-book.styl","hash":"186c37e9c39e65aa291cce3317e35904693598d1","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/sunburst.styl","hash":"e6e4c009b10b9805f0c593446bf013edec47d146","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-blue.styl","hash":"92f4423d4964fcfe34ff7ca6cb21012b5738c697","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/solarized-light.styl","hash":"bb04944fc06c12ecd7b56ad933dbedde60c2259a","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/solarized-dark.styl","hash":"9fc9400d3a8cae97eb5761c284140acb0f847538","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-bright.styl","hash":"e6b025b247e4027fb3c1b7833588f5a5b04a549c","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"8b16876cf205111d5d5454100de712bc3ea8f477","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night.styl","hash":"eb8441364bb1664ecebde77b965dc36c91133aa0","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/tomorrow.styl","hash":"502335f0fac07ed74ca78207bcf3ef8dd2252cf6","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/article.styl","hash":"abdbf82d71c7ec89c2f3ebaf8cc0606ab4ec1e03","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/categories.styl","hash":"92fffe2baacb9d19021b3d120d2038417ca466df","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/xcode.styl","hash":"5fa8999c7f807c1aae29c7a1cdf681678576fb69","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/archive.styl","hash":"301bf71b6878c965b3ea49dc19aba3f1c111cd3a","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/vs.styl","hash":"14fbb0c43af440a290280b26968c8a5c0786b27f","modified":1679761070965},{"_id":"themes/cactus/source/css/_highlight/zenburn.styl","hash":"f63534764dd6598e81177d64714a184f98153b11","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/comments.styl","hash":"6e839bae0ddc11447579c34541e79b50d3670bbd","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/header.styl","hash":"25538f8114e3b31d885bc6421451fdeee3f038b1","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/index.styl","hash":"4a0da5d7052204b23d390a7f76cdc903b9eef52b","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/pagination.styl","hash":"4ff9755163aae6039bb72eac8360bc1c50fa26b6","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/footer.styl","hash":"5bc59fd8cadd7cff06d989c9c7e8e4eb0d0872d8","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/tags.styl","hash":"7a2f9051b21bce525ecb71799d37c4b65a4f9171","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/search.styl","hash":"680ea535e5a20c01a31bee4d3eb680b86267a281","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/tooltip.styl","hash":"6cb13a9f4a7c01aa7ab8f73739a7d385377c5465","modified":1679761070965},{"_id":"themes/cactus/source/lib/clipboard/clipboard.min.js","hash":"67c61939ece0a1d192a3fffec3f8b589538e1d2a","modified":1679761070980},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","hash":"f6fda2de0348b3e3b7de73267f9f8e97a62f8353","modified":1679761071026},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","hash":"7ea4fd7dd4cd4f480af78a0e2c5849eb921b1aeb","modified":1679761071026},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","hash":"6e40d0c7669c1adbcbf034bdc459f7bed4d6676d","modified":1679761071030},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","hash":"56e632c9196fac364c66f812a3b4635dd999ad1c","modified":1679761071029},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","hash":"1c3dbf17411b1f6a6b22c2b76e9d8511586643d0","modified":1679761071033},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","hash":"50b654d916204c30987d1987abd890ef92085ae3","modified":1679761071033},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","hash":"43a8aaa3fca8721dd32a5d20f7a98dfbc87c97fd","modified":1679761071036},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","hash":"14b3e257c51a6a11d23b2a078017ff340c9777e4","modified":1679761071037},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff","hash":"235889d59ddad2b1f3243ccaab7733bd713a2a21","modified":1679761071039},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff2","hash":"a9714ffb842afc74836e64de04b52d8c37c87c8a","modified":1679761071039},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","hash":"c0e784de2eb5261cca244928f8a81fd893c3fe16","modified":1679761071042},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","hash":"9b03b1a9071709f5b7dbca13412ecef6cb7a2a67","modified":1679761071043},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff","hash":"2e8e6d38d361def5f48baac366f04e3db3ed4828","modified":1679761071045},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","hash":"a3dca7ea2f1fedafc2dfb687884d8ac792d15947","modified":1679761071046},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff2","hash":"e213bb26bc7f10e1df3fe2d03d3ecaecd6e6d371","modified":1679761071046},{"_id":"themes/cactus/source/css/_partial/post/actions_desktop.styl","hash":"c25ccdd505ca1b7c74a7fb2365ad2c262f8025ba","modified":1679761070965},{"_id":"themes/cactus/source/css/_partial/post/actions_mobile.styl","hash":"b06410ed34b5ecbcac11357aa359149e1f827aa6","modified":1679761070965},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"d1a7eff18db8a47207ea42e34e9d9fbcc66a97a7","modified":1679761070980},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"be22b700cc80c242da898ef8b7bb96adc4e0899f","modified":1679761070980},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.ttf","hash":"c77fcea87e0c4953f2b0ac92dc49a31c664b6ef7","modified":1679761070991},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.woff2","hash":"60d794c18c2b58b2b76d2ce17b85c44c48fb2efd","modified":1679761070991},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","hash":"4a8d364c99df8471c6a0c7192710631e605af635","modified":1679761070993},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"8d7e041394387fd523991bf827d417ade2747e35","modified":1679761070994},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","hash":"4cd5ddc413b3024d7b56331c0d0d0b2bd933f27f","modified":1679761070993},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","hash":"91152bd73e7ff8d943e3bde3ddb0fa0a018e1c21","modified":1679761071024},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","hash":"b65915e3fa57b5c19995d15dc2341d115c1971b9","modified":1679761071025},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","hash":"5c1c680fade45393e4a5bb4548a092cd5ea6811e","modified":1679761071027},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","hash":"122bb778b17a152c426a825ee981610a4bd59bf3","modified":1679761071029},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","hash":"a059359e9bea17dc2ff2ede955a05bf0dc4d00d0","modified":1679761071031},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","hash":"df82b80c4d3b11e70dcd269fc62ac97cbfa0414d","modified":1679761071032},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","hash":"d9ec1f9f3fefd57e446cbe86dc297f1ff269b6de","modified":1679761071035},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","hash":"948a091f0fdb8c7ae17d5ef8e51bd8830d65dd9a","modified":1679761071036},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.eot","hash":"521c01f0eb79a48025e972ecbe21b0d7fb15437b","modified":1679761071038},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.ttf","hash":"643c28c8f8a2bce1a0d62525aa045cd9883773cd","modified":1679761071038},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","hash":"a0ea0bdaef00b35544f9a21d25d35db9a79f7189","modified":1679761071040},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","hash":"6aacb0eecb03c660570b6e159ba5ca97ca7461cf","modified":1679761071042},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.ttf","hash":"1e08b6373c2e086f24776df9b11e4be6bbcc8a4a","modified":1679761071045},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.eot","hash":"af46f7f4e10a1440a4c97b350622d279143e6798","modified":1679761071044},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","hash":"f6afcccb73ef38a784a1285b0b55b15f5b2e20b5","modified":1679761070980},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"98564e5517b7b455e80b2cd503e7bb3b52beb930","modified":1679761070980},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"cfb2c6122bd53141e939ee4ff991a16a29d1bdce","modified":1679761070980},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"09a731f80844483614ff12f86ccbe41db6736cb5","modified":1679761070991},{"_id":"themes/cactus/source/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1679761070980},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1679761071003},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1679761071006},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1679761071019},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"97f5404656d9547666479ec64c336467000656ef","modified":1679761070980},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1679761071006},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1679761071013},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1679761071021},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1679761071001},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1679761071006},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1679761071006},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1679761071017},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1679761071015},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1679761071022},{"_id":"public/2023/03/26/test/index.html","hash":"15b97a5ebfb8c72fd820c902d8f498f96e334b5c","modified":1679761273620},{"_id":"public/archives/index.html","hash":"ab74ed14c6f573ee739e151271b8c7ba2721be85","modified":1679761273620},{"_id":"public/archives/2023/index.html","hash":"b14c8fec70e8956afd0b2e737ad2fa2a6deec156","modified":1679761273620},{"_id":"public/archives/2023/03/index.html","hash":"7a66917bdb5ff4ca113e6923f4f52f4345d67a9e","modified":1679761273620},{"_id":"public/index.html","hash":"7da9e12c5c11c3724b3a6ead483c5468b1382f7e","modified":1679761273620},{"_id":"public/404.html","hash":"22942d71bd79703fea62f4f10ffb66ac132c4272","modified":1679761273620},{"_id":"public/2023/03/26/hello-world/index.html","hash":"7cfc28778d6ac2cbca3852ba771c176d54ea9e13","modified":1679761273620},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1679761273620},{"_id":"public/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1679761273620},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Black.woff2","hash":"7ea4fd7dd4cd4f480af78a0e2c5849eb921b1aeb","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Black.woff","hash":"f6fda2de0348b3e3b7de73267f9f8e97a62f8353","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Bold.woff","hash":"56e632c9196fac364c66f812a3b4635dd999ad1c","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Bold.woff2","hash":"6e40d0c7669c1adbcbf034bdc459f7bed4d6676d","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Light.woff","hash":"1c3dbf17411b1f6a6b22c2b76e9d8511586643d0","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Light.woff2","hash":"50b654d916204c30987d1987abd890ef92085ae3","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Medium.woff","hash":"43a8aaa3fca8721dd32a5d20f7a98dfbc87c97fd","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Medium.woff2","hash":"14b3e257c51a6a11d23b2a078017ff340c9777e4","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Regular.woff","hash":"235889d59ddad2b1f3243ccaab7733bd713a2a21","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Regular.woff2","hash":"a9714ffb842afc74836e64de04b52d8c37c87c8a","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Thin.woff","hash":"c0e784de2eb5261cca244928f8a81fd893c3fe16","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Thin.woff2","hash":"9b03b1a9071709f5b7dbca13412ecef6cb7a2a67","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Variable.woff","hash":"2e8e6d38d361def5f48baac366f04e3db3ed4828","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Variable.woff2","hash":"e213bb26bc7f10e1df3fe2d03d3ecaecd6e6d371","modified":1679761273620},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"d1a7eff18db8a47207ea42e34e9d9fbcc66a97a7","modified":1679761273620},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"be22b700cc80c242da898ef8b7bb96adc4e0899f","modified":1679761273620},{"_id":"public/lib/font-awesome/webfonts/fa-v4compatibility.woff2","hash":"60d794c18c2b58b2b76d2ce17b85c44c48fb2efd","modified":1679761273620},{"_id":"public/lib/font-awesome/webfonts/fa-v4compatibility.ttf","hash":"c77fcea87e0c4953f2b0ac92dc49a31c664b6ef7","modified":1679761273620},{"_id":"public/css/rtl.css","hash":"9589fac02a34fd9084f805f801889028756bbb65","modified":1679761273620},{"_id":"public/js/search.js","hash":"914a2ce72fb325106c61600200be823b72bfb39f","modified":1679761273620},{"_id":"public/js/main.js","hash":"619ac6529d140711e3b14f739a192bb31c4824ff","modified":1679761273620},{"_id":"public/lib/clipboard/clipboard.min.js","hash":"6674f81dd01c76be986cf0a8172d1073e56d7ef4","modified":1679761273620},{"_id":"public/lib/vazir-font/font-face.css","hash":"ba0030e1cd28a8caa7a5bb74b98da7c7bb185c90","modified":1679761273620},{"_id":"public/lib/justified-gallery/css/justifiedGallery.min.css","hash":"dd3052149d3054f35efb823c68dd78e78aad5875","modified":1679761273620},{"_id":"public/css/style.css","hash":"350ef411c4855773b2f8e0e1fe2e9eb90d540888","modified":1679761273620},{"_id":"public/lib/jquery/jquery.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1679761273620},{"_id":"public/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"ad8f48b4022498078b089fcdd1e8b47faf496931","modified":1679761273620},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"d3cafed4c6596253c1050ee63897aa0f440e4f65","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Black.eot","hash":"91152bd73e7ff8d943e3bde3ddb0fa0a018e1c21","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Black.ttf","hash":"b65915e3fa57b5c19995d15dc2341d115c1971b9","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Bold.ttf","hash":"122bb778b17a152c426a825ee981610a4bd59bf3","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Bold.eot","hash":"5c1c680fade45393e4a5bb4548a092cd5ea6811e","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Light.eot","hash":"a059359e9bea17dc2ff2ede955a05bf0dc4d00d0","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Light.ttf","hash":"df82b80c4d3b11e70dcd269fc62ac97cbfa0414d","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Medium.eot","hash":"d9ec1f9f3fefd57e446cbe86dc297f1ff269b6de","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Medium.ttf","hash":"948a091f0fdb8c7ae17d5ef8e51bd8830d65dd9a","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Regular.eot","hash":"521c01f0eb79a48025e972ecbe21b0d7fb15437b","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Regular.ttf","hash":"643c28c8f8a2bce1a0d62525aa045cd9883773cd","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Thin.eot","hash":"a0ea0bdaef00b35544f9a21d25d35db9a79f7189","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Thin.ttf","hash":"6aacb0eecb03c660570b6e159ba5ca97ca7461cf","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Variable.eot","hash":"af46f7f4e10a1440a4c97b350622d279143e6798","modified":1679761273620},{"_id":"public/lib/vazir-font/Vazir-Variable.ttf","hash":"1e08b6373c2e086f24776df9b11e4be6bbcc8a4a","modified":1679761273620},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"98564e5517b7b455e80b2cd503e7bb3b52beb930","modified":1679761273620},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"cfb2c6122bd53141e939ee4ff991a16a29d1bdce","modified":1679761273620},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"09a731f80844483614ff12f86ccbe41db6736cb5","modified":1679761273620},{"_id":"public/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1679761273620},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"97f5404656d9547666479ec64c336467000656ef","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1679761273620},{"_id":"public/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1679761273620},{"_id":"source/_posts/2023 变化的一年.md","hash":"fc7a7b9bd1ab140a1b8bddf478ce1ad36aa33062","modified":1681549033627},{"_id":"source/_posts/A plain english introduction to CAP Theorem.md","hash":"e16e03c7f94adb59bfead4af88c3c5127f02719e","modified":1681549033627},{"_id":"source/_posts/exit函数与僵尸进程.md","hash":"dee5c822efbb7215c4a79439e7e0d0d542adbe5c","modified":1681549033629},{"_id":"source/_posts/可重入函数与线程安全.md","hash":"642c8705f654869627c98a489c2e5f1627e17542","modified":1681549033630},{"_id":"source/_posts/MIT-6-824与Raft共识算法.md","hash":"5c5c3d323a717a30720850cc71dab126977f9620","modified":1681549033628},{"_id":"source/_posts/动态连接和静态连接.md","hash":"475240da3c5e59085fb7029f9f1f35b8f5f5bd69","modified":1681549033629},{"_id":"source/_posts/快速上手Docker.md","hash":"d335030edbb1fbfaa8881c44fa780421d987a92d","modified":1681552891237}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"post","title":"2023 变化的一年","date":"2023-03-30T00:00:00.000Z","_content":"\n2023年刚开始就注定是不平凡的一年，这一年做的决定可能对自己的人生产生长远的影响，因此开一个流水账的帖子记录下来\n\n## 2月，绩效考核\n2月份,公司公布了2022年全年的绩效考核，出乎意外的我竟然拿了一个B，华为的绩效考核分为A，B+，B，C，相对来讲，B已经是属于后10%了，这让我一下有了危机，仔细思考去年到底哪里做的不好，想来想去得到一个结论，被人投诉了，这也怪我，去年接了一个坑爹的岗位，需要大量与人沟通，尤其是和版本经理和服务代表，遗憾的是这两个人气场和我严重不合，而我又确实不是那种见人说人话见鬼说鬼话的人，无可避免的和人吵了几次架，于是人家就在领导面前投诉我了，说实话去年一年干的活真是又苦又累，几乎天天都在扯皮，不搞技术让人心理感觉不踏实，拿到这个绩效结果我立即萌生了转岗的念头，当前所在的核心网行门槛很高，全球都没有几家公司搞，假如我从华为离开了那几乎就等于失业，观察了一下周围干了很久的同事在离开以后的处境，无一例外还是围绕着华为的产业，要么是外包要么是外聘，那我又应该换到哪个领域呢？\n\n### 5 AM Project\n2月初在YouTube上看到一个叫做MoneyXYZ的博主，他讲了一个5AM Project的概念，大概原理就是养成早睡早起的习惯然后早上起来以后利用早起的时间独立做一些自己喜欢做的事情，这个计划看起来非常适合我，我急需独立的时间，但是早上5点起的话至少晚上10点就要睡觉，这对我来说有点不太可能，我先从早上7点起开始，晚上11点半睡觉，因此至少可以保证7个小时的睡眠，我尝试了几天效果不错，我开始学习一些数据库领域的知识，开始看CMU和MIT的公开课，并且尝试用早上的时间去做对应的作业和项目，目前来看效果还不错，我其实想起的更早，但是我目前的睡眠质量实在不高，因此只能7点起来，后期在尝试更早吧。\n\n这个视频在这里：\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/4zXTyc2ZjXM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n### 新的领域，数据库\n去年下半年开始一直在自学数据库方面的东西，又再考虑转领域，所以我在考虑是否转到数据库领域，因为自己在游戏在电信领域都干了很多年，说实话从游戏到电信我认为我把路走窄了，因为电信领域相对是非常封闭的地方，我更想回到互联网公司那种自由和开放的氛围，数据库领域看起来是一个很通用的技术，我认为发展前景应该不错；搞数据库的部门很多，我最终选择了高斯DB，无论如何先进入这个领域再说；在华为转岗是一件危险的事情，这会极大的影响职业生涯，尤其是高级别人员，但是即使这样我也要赌一次，最起码要做一些自己喜欢的事情吧；\n\n## 3月，和领导们的谈话，以及甲流\n在我发起调动的第二天，领导就找到我谈话，尝试对我挽留，我其实很讨厌这种形式主义，应付领导们的挽留很麻烦，因为每次谈完话领导都让我再考虑一下，然后过几天就会问我考虑的怎么样了？我不得不想一个既不把关系搞僵又得拒绝她的说法，实在是很累。\n\n### 甲型流感\n在新冠结束以后，甲流又开始流行，幸运的是我家里人似乎都还好，小孩子好像也只是感染了普通感冒，低烧了两天也差不多好了。只是鼻子有鼻涕，嗓子也有痰，去医院开了一些消炎药，现在也好多了。看来以后还是要坚持每年接种流感疫苗\n\n## 4月，清明，北京和内心的纠结\n领导的攻势比我想象中要厉害很多，本来前三个领导和我沟通完我是没有任何动摇的，但是开发部长和我沟通完了以后我着实动摇了，不愧是级别高，对人性的拿捏真的很到位；从这天开始我仔细考虑了这件事，无论如何，对于没有发生的事情，只能靠猜测，承诺都是未知状态，对于此，只能遵从自己的内心。\n4月，领导安排去北京参加数据库嘉年华大会，我顶着大风坐着摇摇晃晃的飞机来到了首都大兴机场，逛了什刹海，吃了全聚德烤鸭，在领导安排的两位专家的攻势下，仍然坚持要走，这种纠结是一种心理和生理上的双重折磨，我必须趁早做决定；现在我在北京的酒店里写下这段话，几个小时前，我刚刚给领导打完电话，明确了我要走，领导还是坚持让我去东莞，我知道他还是没有放弃我，还准备对我进行再次的劝说，我可能还得再次忍受煎熬；其实这是一次十分艰难的选择，因为每次选择都伴随着风险，去了那边到底要面对的是什么，其实仍旧是一种未知。在网上看到一段话，觉得写的很好：\n\n小时候觉得忘带作业是天大的事，高中的时候觉得考不上大学是天大的事，恋爱的时候觉得和喜欢的人分开是天大的事，大学毕业的时候觉得找不到工作是天大的事，现在回过头来看，那些曾经觉得跨不过的山，也都跨过来了，曾经觉得天塌了的事情，也都熬过去了，生活充满了选择，遗憾不过是常态，失败也是贯穿人生始终的，其实人本身就是无论做什么选择都会后悔，因为总是习惯去美化自己未选择的道路，但是大家都知道，就算重来一次，在当前的心智和认知下，你还是会做出相同的选择，那么结局可能就没那么重要了，就去享受这个过程吧。\n","source":"_posts/2023 变化的一年.md","raw":"---\nlayout: post\ntitle: \"2023 变化的一年\"\ndate: \"2023-03-30\"\ntags: [流水账]\n---\n\n2023年刚开始就注定是不平凡的一年，这一年做的决定可能对自己的人生产生长远的影响，因此开一个流水账的帖子记录下来\n\n## 2月，绩效考核\n2月份,公司公布了2022年全年的绩效考核，出乎意外的我竟然拿了一个B，华为的绩效考核分为A，B+，B，C，相对来讲，B已经是属于后10%了，这让我一下有了危机，仔细思考去年到底哪里做的不好，想来想去得到一个结论，被人投诉了，这也怪我，去年接了一个坑爹的岗位，需要大量与人沟通，尤其是和版本经理和服务代表，遗憾的是这两个人气场和我严重不合，而我又确实不是那种见人说人话见鬼说鬼话的人，无可避免的和人吵了几次架，于是人家就在领导面前投诉我了，说实话去年一年干的活真是又苦又累，几乎天天都在扯皮，不搞技术让人心理感觉不踏实，拿到这个绩效结果我立即萌生了转岗的念头，当前所在的核心网行门槛很高，全球都没有几家公司搞，假如我从华为离开了那几乎就等于失业，观察了一下周围干了很久的同事在离开以后的处境，无一例外还是围绕着华为的产业，要么是外包要么是外聘，那我又应该换到哪个领域呢？\n\n### 5 AM Project\n2月初在YouTube上看到一个叫做MoneyXYZ的博主，他讲了一个5AM Project的概念，大概原理就是养成早睡早起的习惯然后早上起来以后利用早起的时间独立做一些自己喜欢做的事情，这个计划看起来非常适合我，我急需独立的时间，但是早上5点起的话至少晚上10点就要睡觉，这对我来说有点不太可能，我先从早上7点起开始，晚上11点半睡觉，因此至少可以保证7个小时的睡眠，我尝试了几天效果不错，我开始学习一些数据库领域的知识，开始看CMU和MIT的公开课，并且尝试用早上的时间去做对应的作业和项目，目前来看效果还不错，我其实想起的更早，但是我目前的睡眠质量实在不高，因此只能7点起来，后期在尝试更早吧。\n\n这个视频在这里：\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/4zXTyc2ZjXM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n### 新的领域，数据库\n去年下半年开始一直在自学数据库方面的东西，又再考虑转领域，所以我在考虑是否转到数据库领域，因为自己在游戏在电信领域都干了很多年，说实话从游戏到电信我认为我把路走窄了，因为电信领域相对是非常封闭的地方，我更想回到互联网公司那种自由和开放的氛围，数据库领域看起来是一个很通用的技术，我认为发展前景应该不错；搞数据库的部门很多，我最终选择了高斯DB，无论如何先进入这个领域再说；在华为转岗是一件危险的事情，这会极大的影响职业生涯，尤其是高级别人员，但是即使这样我也要赌一次，最起码要做一些自己喜欢的事情吧；\n\n## 3月，和领导们的谈话，以及甲流\n在我发起调动的第二天，领导就找到我谈话，尝试对我挽留，我其实很讨厌这种形式主义，应付领导们的挽留很麻烦，因为每次谈完话领导都让我再考虑一下，然后过几天就会问我考虑的怎么样了？我不得不想一个既不把关系搞僵又得拒绝她的说法，实在是很累。\n\n### 甲型流感\n在新冠结束以后，甲流又开始流行，幸运的是我家里人似乎都还好，小孩子好像也只是感染了普通感冒，低烧了两天也差不多好了。只是鼻子有鼻涕，嗓子也有痰，去医院开了一些消炎药，现在也好多了。看来以后还是要坚持每年接种流感疫苗\n\n## 4月，清明，北京和内心的纠结\n领导的攻势比我想象中要厉害很多，本来前三个领导和我沟通完我是没有任何动摇的，但是开发部长和我沟通完了以后我着实动摇了，不愧是级别高，对人性的拿捏真的很到位；从这天开始我仔细考虑了这件事，无论如何，对于没有发生的事情，只能靠猜测，承诺都是未知状态，对于此，只能遵从自己的内心。\n4月，领导安排去北京参加数据库嘉年华大会，我顶着大风坐着摇摇晃晃的飞机来到了首都大兴机场，逛了什刹海，吃了全聚德烤鸭，在领导安排的两位专家的攻势下，仍然坚持要走，这种纠结是一种心理和生理上的双重折磨，我必须趁早做决定；现在我在北京的酒店里写下这段话，几个小时前，我刚刚给领导打完电话，明确了我要走，领导还是坚持让我去东莞，我知道他还是没有放弃我，还准备对我进行再次的劝说，我可能还得再次忍受煎熬；其实这是一次十分艰难的选择，因为每次选择都伴随着风险，去了那边到底要面对的是什么，其实仍旧是一种未知。在网上看到一段话，觉得写的很好：\n\n小时候觉得忘带作业是天大的事，高中的时候觉得考不上大学是天大的事，恋爱的时候觉得和喜欢的人分开是天大的事，大学毕业的时候觉得找不到工作是天大的事，现在回过头来看，那些曾经觉得跨不过的山，也都跨过来了，曾经觉得天塌了的事情，也都熬过去了，生活充满了选择，遗憾不过是常态，失败也是贯穿人生始终的，其实人本身就是无论做什么选择都会后悔，因为总是习惯去美化自己未选择的道路，但是大家都知道，就算重来一次，在当前的心智和认知下，你还是会做出相同的选择，那么结局可能就没那么重要了，就去享受这个过程吧。\n","slug":"2023 变化的一年","published":1,"updated":"2023-04-15T08:57:13.627Z","comments":1,"photos":[],"link":"","_id":"clghs86jx0000sgvifk67gdwu","content":"<p>2023年刚开始就注定是不平凡的一年，这一年做的决定可能对自己的人生产生长远的影响，因此开一个流水账的帖子记录下来</p>\n<h2 id=\"2月，绩效考核\"><a href=\"#2月，绩效考核\" class=\"headerlink\" title=\"2月，绩效考核\"></a>2月，绩效考核</h2><p>2月份,公司公布了2022年全年的绩效考核，出乎意外的我竟然拿了一个B，华为的绩效考核分为A，B+，B，C，相对来讲，B已经是属于后10%了，这让我一下有了危机，仔细思考去年到底哪里做的不好，想来想去得到一个结论，被人投诉了，这也怪我，去年接了一个坑爹的岗位，需要大量与人沟通，尤其是和版本经理和服务代表，遗憾的是这两个人气场和我严重不合，而我又确实不是那种见人说人话见鬼说鬼话的人，无可避免的和人吵了几次架，于是人家就在领导面前投诉我了，说实话去年一年干的活真是又苦又累，几乎天天都在扯皮，不搞技术让人心理感觉不踏实，拿到这个绩效结果我立即萌生了转岗的念头，当前所在的核心网行门槛很高，全球都没有几家公司搞，假如我从华为离开了那几乎就等于失业，观察了一下周围干了很久的同事在离开以后的处境，无一例外还是围绕着华为的产业，要么是外包要么是外聘，那我又应该换到哪个领域呢？</p>\n<h3 id=\"5-AM-Project\"><a href=\"#5-AM-Project\" class=\"headerlink\" title=\"5 AM Project\"></a>5 AM Project</h3><p>2月初在YouTube上看到一个叫做MoneyXYZ的博主，他讲了一个5AM Project的概念，大概原理就是养成早睡早起的习惯然后早上起来以后利用早起的时间独立做一些自己喜欢做的事情，这个计划看起来非常适合我，我急需独立的时间，但是早上5点起的话至少晚上10点就要睡觉，这对我来说有点不太可能，我先从早上7点起开始，晚上11点半睡觉，因此至少可以保证7个小时的睡眠，我尝试了几天效果不错，我开始学习一些数据库领域的知识，开始看CMU和MIT的公开课，并且尝试用早上的时间去做对应的作业和项目，目前来看效果还不错，我其实想起的更早，但是我目前的睡眠质量实在不高，因此只能7点起来，后期在尝试更早吧。</p>\n<p>这个视频在这里：</p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/4zXTyc2ZjXM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n<h3 id=\"新的领域，数据库\"><a href=\"#新的领域，数据库\" class=\"headerlink\" title=\"新的领域，数据库\"></a>新的领域，数据库</h3><p>去年下半年开始一直在自学数据库方面的东西，又再考虑转领域，所以我在考虑是否转到数据库领域，因为自己在游戏在电信领域都干了很多年，说实话从游戏到电信我认为我把路走窄了，因为电信领域相对是非常封闭的地方，我更想回到互联网公司那种自由和开放的氛围，数据库领域看起来是一个很通用的技术，我认为发展前景应该不错；搞数据库的部门很多，我最终选择了高斯DB，无论如何先进入这个领域再说；在华为转岗是一件危险的事情，这会极大的影响职业生涯，尤其是高级别人员，但是即使这样我也要赌一次，最起码要做一些自己喜欢的事情吧；</p>\n<h2 id=\"3月，和领导们的谈话，以及甲流\"><a href=\"#3月，和领导们的谈话，以及甲流\" class=\"headerlink\" title=\"3月，和领导们的谈话，以及甲流\"></a>3月，和领导们的谈话，以及甲流</h2><p>在我发起调动的第二天，领导就找到我谈话，尝试对我挽留，我其实很讨厌这种形式主义，应付领导们的挽留很麻烦，因为每次谈完话领导都让我再考虑一下，然后过几天就会问我考虑的怎么样了？我不得不想一个既不把关系搞僵又得拒绝她的说法，实在是很累。</p>\n<h3 id=\"甲型流感\"><a href=\"#甲型流感\" class=\"headerlink\" title=\"甲型流感\"></a>甲型流感</h3><p>在新冠结束以后，甲流又开始流行，幸运的是我家里人似乎都还好，小孩子好像也只是感染了普通感冒，低烧了两天也差不多好了。只是鼻子有鼻涕，嗓子也有痰，去医院开了一些消炎药，现在也好多了。看来以后还是要坚持每年接种流感疫苗</p>\n<h2 id=\"4月，清明，北京和内心的纠结\"><a href=\"#4月，清明，北京和内心的纠结\" class=\"headerlink\" title=\"4月，清明，北京和内心的纠结\"></a>4月，清明，北京和内心的纠结</h2><p>领导的攻势比我想象中要厉害很多，本来前三个领导和我沟通完我是没有任何动摇的，但是开发部长和我沟通完了以后我着实动摇了，不愧是级别高，对人性的拿捏真的很到位；从这天开始我仔细考虑了这件事，无论如何，对于没有发生的事情，只能靠猜测，承诺都是未知状态，对于此，只能遵从自己的内心。<br>4月，领导安排去北京参加数据库嘉年华大会，我顶着大风坐着摇摇晃晃的飞机来到了首都大兴机场，逛了什刹海，吃了全聚德烤鸭，在领导安排的两位专家的攻势下，仍然坚持要走，这种纠结是一种心理和生理上的双重折磨，我必须趁早做决定；现在我在北京的酒店里写下这段话，几个小时前，我刚刚给领导打完电话，明确了我要走，领导还是坚持让我去东莞，我知道他还是没有放弃我，还准备对我进行再次的劝说，我可能还得再次忍受煎熬；其实这是一次十分艰难的选择，因为每次选择都伴随着风险，去了那边到底要面对的是什么，其实仍旧是一种未知。在网上看到一段话，觉得写的很好：</p>\n<p>小时候觉得忘带作业是天大的事，高中的时候觉得考不上大学是天大的事，恋爱的时候觉得和喜欢的人分开是天大的事，大学毕业的时候觉得找不到工作是天大的事，现在回过头来看，那些曾经觉得跨不过的山，也都跨过来了，曾经觉得天塌了的事情，也都熬过去了，生活充满了选择，遗憾不过是常态，失败也是贯穿人生始终的，其实人本身就是无论做什么选择都会后悔，因为总是习惯去美化自己未选择的道路，但是大家都知道，就算重来一次，在当前的心智和认知下，你还是会做出相同的选择，那么结局可能就没那么重要了，就去享受这个过程吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2023年刚开始就注定是不平凡的一年，这一年做的决定可能对自己的人生产生长远的影响，因此开一个流水账的帖子记录下来</p>\n<h2 id=\"2月，绩效考核\"><a href=\"#2月，绩效考核\" class=\"headerlink\" title=\"2月，绩效考核\"></a>2月，绩效考核</h2><p>2月份,公司公布了2022年全年的绩效考核，出乎意外的我竟然拿了一个B，华为的绩效考核分为A，B+，B，C，相对来讲，B已经是属于后10%了，这让我一下有了危机，仔细思考去年到底哪里做的不好，想来想去得到一个结论，被人投诉了，这也怪我，去年接了一个坑爹的岗位，需要大量与人沟通，尤其是和版本经理和服务代表，遗憾的是这两个人气场和我严重不合，而我又确实不是那种见人说人话见鬼说鬼话的人，无可避免的和人吵了几次架，于是人家就在领导面前投诉我了，说实话去年一年干的活真是又苦又累，几乎天天都在扯皮，不搞技术让人心理感觉不踏实，拿到这个绩效结果我立即萌生了转岗的念头，当前所在的核心网行门槛很高，全球都没有几家公司搞，假如我从华为离开了那几乎就等于失业，观察了一下周围干了很久的同事在离开以后的处境，无一例外还是围绕着华为的产业，要么是外包要么是外聘，那我又应该换到哪个领域呢？</p>\n<h3 id=\"5-AM-Project\"><a href=\"#5-AM-Project\" class=\"headerlink\" title=\"5 AM Project\"></a>5 AM Project</h3><p>2月初在YouTube上看到一个叫做MoneyXYZ的博主，他讲了一个5AM Project的概念，大概原理就是养成早睡早起的习惯然后早上起来以后利用早起的时间独立做一些自己喜欢做的事情，这个计划看起来非常适合我，我急需独立的时间，但是早上5点起的话至少晚上10点就要睡觉，这对我来说有点不太可能，我先从早上7点起开始，晚上11点半睡觉，因此至少可以保证7个小时的睡眠，我尝试了几天效果不错，我开始学习一些数据库领域的知识，开始看CMU和MIT的公开课，并且尝试用早上的时间去做对应的作业和项目，目前来看效果还不错，我其实想起的更早，但是我目前的睡眠质量实在不高，因此只能7点起来，后期在尝试更早吧。</p>\n<p>这个视频在这里：</p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/4zXTyc2ZjXM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n\n<h3 id=\"新的领域，数据库\"><a href=\"#新的领域，数据库\" class=\"headerlink\" title=\"新的领域，数据库\"></a>新的领域，数据库</h3><p>去年下半年开始一直在自学数据库方面的东西，又再考虑转领域，所以我在考虑是否转到数据库领域，因为自己在游戏在电信领域都干了很多年，说实话从游戏到电信我认为我把路走窄了，因为电信领域相对是非常封闭的地方，我更想回到互联网公司那种自由和开放的氛围，数据库领域看起来是一个很通用的技术，我认为发展前景应该不错；搞数据库的部门很多，我最终选择了高斯DB，无论如何先进入这个领域再说；在华为转岗是一件危险的事情，这会极大的影响职业生涯，尤其是高级别人员，但是即使这样我也要赌一次，最起码要做一些自己喜欢的事情吧；</p>\n<h2 id=\"3月，和领导们的谈话，以及甲流\"><a href=\"#3月，和领导们的谈话，以及甲流\" class=\"headerlink\" title=\"3月，和领导们的谈话，以及甲流\"></a>3月，和领导们的谈话，以及甲流</h2><p>在我发起调动的第二天，领导就找到我谈话，尝试对我挽留，我其实很讨厌这种形式主义，应付领导们的挽留很麻烦，因为每次谈完话领导都让我再考虑一下，然后过几天就会问我考虑的怎么样了？我不得不想一个既不把关系搞僵又得拒绝她的说法，实在是很累。</p>\n<h3 id=\"甲型流感\"><a href=\"#甲型流感\" class=\"headerlink\" title=\"甲型流感\"></a>甲型流感</h3><p>在新冠结束以后，甲流又开始流行，幸运的是我家里人似乎都还好，小孩子好像也只是感染了普通感冒，低烧了两天也差不多好了。只是鼻子有鼻涕，嗓子也有痰，去医院开了一些消炎药，现在也好多了。看来以后还是要坚持每年接种流感疫苗</p>\n<h2 id=\"4月，清明，北京和内心的纠结\"><a href=\"#4月，清明，北京和内心的纠结\" class=\"headerlink\" title=\"4月，清明，北京和内心的纠结\"></a>4月，清明，北京和内心的纠结</h2><p>领导的攻势比我想象中要厉害很多，本来前三个领导和我沟通完我是没有任何动摇的，但是开发部长和我沟通完了以后我着实动摇了，不愧是级别高，对人性的拿捏真的很到位；从这天开始我仔细考虑了这件事，无论如何，对于没有发生的事情，只能靠猜测，承诺都是未知状态，对于此，只能遵从自己的内心。<br>4月，领导安排去北京参加数据库嘉年华大会，我顶着大风坐着摇摇晃晃的飞机来到了首都大兴机场，逛了什刹海，吃了全聚德烤鸭，在领导安排的两位专家的攻势下，仍然坚持要走，这种纠结是一种心理和生理上的双重折磨，我必须趁早做决定；现在我在北京的酒店里写下这段话，几个小时前，我刚刚给领导打完电话，明确了我要走，领导还是坚持让我去东莞，我知道他还是没有放弃我，还准备对我进行再次的劝说，我可能还得再次忍受煎熬；其实这是一次十分艰难的选择，因为每次选择都伴随着风险，去了那边到底要面对的是什么，其实仍旧是一种未知。在网上看到一段话，觉得写的很好：</p>\n<p>小时候觉得忘带作业是天大的事，高中的时候觉得考不上大学是天大的事，恋爱的时候觉得和喜欢的人分开是天大的事，大学毕业的时候觉得找不到工作是天大的事，现在回过头来看，那些曾经觉得跨不过的山，也都跨过来了，曾经觉得天塌了的事情，也都熬过去了，生活充满了选择，遗憾不过是常态，失败也是贯穿人生始终的，其实人本身就是无论做什么选择都会后悔，因为总是习惯去美化自己未选择的道路，但是大家都知道，就算重来一次，在当前的心智和认知下，你还是会做出相同的选择，那么结局可能就没那么重要了，就去享受这个过程吧。</p>\n"},{"title":"MIT 6.824与Raft共识算法","date":"2023-04-02T23:25:53.000Z","_content":"\n## Raft 共识算法\nRaft是非常出名的一个共识算法，关于Raft的介绍网络上已经有很多帖子了，但我建议你还是直接看原版[论文](https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf)，如果英语不行，先看中文[翻译版](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)\n\n了解的差不多了以后，基本上就要开始动手去写一个Raft了，这里推荐直接使用MIT 6.824的实验来做，比较容易上手，注意这个实验是使用Go语言做的，如果不熟悉Go语言，可以快速学习一下\n\n## MIT 6.824\nMIT 6.824是一个关于分布式算法的公开课，一般和数据库内核相关的课程一起学习（例如CMU15-445）,这个课的完整视频可以在[这里](https://www.bilibili.com/video/BV1R7411t71W/?p=2&vd_source=38ddec4d9f5d5a36fb2df2883f091000)看到。\n\n我并没有把这个课程看完，我的重点在于这个课程的第二个Lab，用Go语言做了一个Raft，这是入门Raft的一个好材料，该Lab的地址在[这里](http://nil.csail.mit.edu/6.824/2022/labs/lab-raft.html)，提交作业的地址在[这里](https://6824.scripts.mit.edu/2022/handin.py)\n\n由于时间关系，我也没有把这个实验做完，只做了前两部，即：选举和日志同步，我的代码在：https://github.com/eddyli1989/6.824\n我不建议你直接看答案\n\n下面是一些大方向之类的建议：\n- 在自己动手编写之前，不建议你在网上看别人的答案\n- 不要着急写代码，在写代码之前先想好程序的主要结构是什么样子，需要什么数据结构，如何驱动整个程序，甚至每个场景下应该如何处理，都先想好，如果实在想不出来，可以画流程图\n- 搞清楚每个状态下的每个变量是干啥用的，否则你只能在一次次莫名其妙的失败中去定位，非常消耗时间\n\n## 选举阶段\n- 在实现选举阶段之前，你需要先明确整个程序的运行框架，整个程序基于一个定时器不停的循环，需要新增一个Role变量，用来保存当前的角色，然后再定时器中根据角色的不同，进入不同的函数，这是程序的大框架\n- 确定选举定时器的超时时间，以及随机的时间范围，论文中建议为150-300ms，实际可能需要比这个时间更大，经过多次尝试，这个时间我最终选择了300~450ms\n- 随机数的选择，不要用rand，rand是假随机数，会导致几乎每次随机得到的时间都是固定的，会出现如下情况：当有2~3个节点，而这2~3个节点中，哪个节点满足成为Leader的条件是固定的，但是由于假随机数导致，该节点的定时器总是晚于其他节点，从而导致该节点一直无法赢得选举(瓜分选票，即：每个节点都投票给自己)，这种情况最终会导致用例的失败，因此我选择了crypto/rand.\n- 在第一个2A作业中，你不需要在RequestVote请求里对比日志，这个是2B的部分\n- 每一个节点在每一个Term中，只能投一张票，注意，是每一个Term，所以如果在Term1投给自己，现在收到Term2的投票请求，你还是要投给别人\n- 注意加锁，且不要死锁，在跑test的时候加上-race参数，控制锁的粒度，不要在休眠的时候仍然持有锁\n- 在广播请求时，注意过滤掉自己\n- 在任何阶段，收到一个响应中的Term比自己的Term大，立即变为Folowwer\n- 本实验中的RPC为同步调用，即：在未收到响应前会阻塞，且网络被设定为不可靠，所以任何一个请求的时延可能是不固定的\n- 基于以上原因，建议采用gorouting+chan的异步方式对同步调用进行封装，否则比较难以进行下去\n- 如果接纳了别人的投票，那角色应该变为Folowwer\n- 在变为Leader以后，马上发送AppendEntries\n\n## 日志同步\n- 在RequestVote里要判断谁的日志更新，注意：论文中对谁的日志更新有准确描述，不要臆测，并不是谁的日志越长谁的就更新\n- Start接口在Leader把日志添加到自己的Log数组中就可以返回了，并不用等待同步给其他节点\n- nextIndex的含义，指的是下次同步日志的时候，可以尝试从该索引同步，但并不保障一定能同步成功\n- matchIndex的含义，是用来校准commitIndex的，如果大多数节点的matchIndex都大于某个数，那么commitIndex应该被设置为这个数字\n- matchIndex决定了lastApplied，理论上lastApplied<=matchIndex\n- 应用到自动机的意思就是 构造一个ApplyMsg并把他送到applyCh，在当前场景下ApplyMsg的CommandValid应该被一直设置为true。在实际应用中，应用到自动机的意思应该是，针对该日志对数据做正式的修改，例如该日志是想set x = 10，那么应用到自动机的含义应该就是把x这个key的值设置为10.\n- AppendEntriesArgs中的LeaderCommit扮演了重要角色，他实际上是2PC中的第二阶段，因为LeaderCommit可以控制Folowwer节点的commitIndex，从而控制Folowwer节点的日志提交(lastApplied)，一般正常的流程是：主节点收到Start，然后通过日志同步到子节点，然后主节点提交该日志，并在下一次心跳时，将LeaderCommit带给子节点，然后子节点才会去提交该日志。","source":"_posts/MIT-6-824与Raft共识算法.md","raw":"---\ntitle: MIT 6.824与Raft共识算法\ndate: 2023-04-03 07:25:53\ntags: [\"Raft\",\"分布式\"]\n---\n\n## Raft 共识算法\nRaft是非常出名的一个共识算法，关于Raft的介绍网络上已经有很多帖子了，但我建议你还是直接看原版[论文](https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf)，如果英语不行，先看中文[翻译版](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)\n\n了解的差不多了以后，基本上就要开始动手去写一个Raft了，这里推荐直接使用MIT 6.824的实验来做，比较容易上手，注意这个实验是使用Go语言做的，如果不熟悉Go语言，可以快速学习一下\n\n## MIT 6.824\nMIT 6.824是一个关于分布式算法的公开课，一般和数据库内核相关的课程一起学习（例如CMU15-445）,这个课的完整视频可以在[这里](https://www.bilibili.com/video/BV1R7411t71W/?p=2&vd_source=38ddec4d9f5d5a36fb2df2883f091000)看到。\n\n我并没有把这个课程看完，我的重点在于这个课程的第二个Lab，用Go语言做了一个Raft，这是入门Raft的一个好材料，该Lab的地址在[这里](http://nil.csail.mit.edu/6.824/2022/labs/lab-raft.html)，提交作业的地址在[这里](https://6824.scripts.mit.edu/2022/handin.py)\n\n由于时间关系，我也没有把这个实验做完，只做了前两部，即：选举和日志同步，我的代码在：https://github.com/eddyli1989/6.824\n我不建议你直接看答案\n\n下面是一些大方向之类的建议：\n- 在自己动手编写之前，不建议你在网上看别人的答案\n- 不要着急写代码，在写代码之前先想好程序的主要结构是什么样子，需要什么数据结构，如何驱动整个程序，甚至每个场景下应该如何处理，都先想好，如果实在想不出来，可以画流程图\n- 搞清楚每个状态下的每个变量是干啥用的，否则你只能在一次次莫名其妙的失败中去定位，非常消耗时间\n\n## 选举阶段\n- 在实现选举阶段之前，你需要先明确整个程序的运行框架，整个程序基于一个定时器不停的循环，需要新增一个Role变量，用来保存当前的角色，然后再定时器中根据角色的不同，进入不同的函数，这是程序的大框架\n- 确定选举定时器的超时时间，以及随机的时间范围，论文中建议为150-300ms，实际可能需要比这个时间更大，经过多次尝试，这个时间我最终选择了300~450ms\n- 随机数的选择，不要用rand，rand是假随机数，会导致几乎每次随机得到的时间都是固定的，会出现如下情况：当有2~3个节点，而这2~3个节点中，哪个节点满足成为Leader的条件是固定的，但是由于假随机数导致，该节点的定时器总是晚于其他节点，从而导致该节点一直无法赢得选举(瓜分选票，即：每个节点都投票给自己)，这种情况最终会导致用例的失败，因此我选择了crypto/rand.\n- 在第一个2A作业中，你不需要在RequestVote请求里对比日志，这个是2B的部分\n- 每一个节点在每一个Term中，只能投一张票，注意，是每一个Term，所以如果在Term1投给自己，现在收到Term2的投票请求，你还是要投给别人\n- 注意加锁，且不要死锁，在跑test的时候加上-race参数，控制锁的粒度，不要在休眠的时候仍然持有锁\n- 在广播请求时，注意过滤掉自己\n- 在任何阶段，收到一个响应中的Term比自己的Term大，立即变为Folowwer\n- 本实验中的RPC为同步调用，即：在未收到响应前会阻塞，且网络被设定为不可靠，所以任何一个请求的时延可能是不固定的\n- 基于以上原因，建议采用gorouting+chan的异步方式对同步调用进行封装，否则比较难以进行下去\n- 如果接纳了别人的投票，那角色应该变为Folowwer\n- 在变为Leader以后，马上发送AppendEntries\n\n## 日志同步\n- 在RequestVote里要判断谁的日志更新，注意：论文中对谁的日志更新有准确描述，不要臆测，并不是谁的日志越长谁的就更新\n- Start接口在Leader把日志添加到自己的Log数组中就可以返回了，并不用等待同步给其他节点\n- nextIndex的含义，指的是下次同步日志的时候，可以尝试从该索引同步，但并不保障一定能同步成功\n- matchIndex的含义，是用来校准commitIndex的，如果大多数节点的matchIndex都大于某个数，那么commitIndex应该被设置为这个数字\n- matchIndex决定了lastApplied，理论上lastApplied<=matchIndex\n- 应用到自动机的意思就是 构造一个ApplyMsg并把他送到applyCh，在当前场景下ApplyMsg的CommandValid应该被一直设置为true。在实际应用中，应用到自动机的意思应该是，针对该日志对数据做正式的修改，例如该日志是想set x = 10，那么应用到自动机的含义应该就是把x这个key的值设置为10.\n- AppendEntriesArgs中的LeaderCommit扮演了重要角色，他实际上是2PC中的第二阶段，因为LeaderCommit可以控制Folowwer节点的commitIndex，从而控制Folowwer节点的日志提交(lastApplied)，一般正常的流程是：主节点收到Start，然后通过日志同步到子节点，然后主节点提交该日志，并在下一次心跳时，将LeaderCommit带给子节点，然后子节点才会去提交该日志。","slug":"MIT-6-824与Raft共识算法","published":1,"updated":"2023-04-15T08:57:13.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clghs86k10001sgvifqd67ypx","content":"<h2 id=\"Raft-共识算法\"><a href=\"#Raft-共识算法\" class=\"headerlink\" title=\"Raft 共识算法\"></a>Raft 共识算法</h2><p>Raft是非常出名的一个共识算法，关于Raft的介绍网络上已经有很多帖子了，但我建议你还是直接看原版<a href=\"https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf\">论文</a>，如果英语不行，先看中文<a href=\"https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md\">翻译版</a></p>\n<p>了解的差不多了以后，基本上就要开始动手去写一个Raft了，这里推荐直接使用MIT 6.824的实验来做，比较容易上手，注意这个实验是使用Go语言做的，如果不熟悉Go语言，可以快速学习一下</p>\n<h2 id=\"MIT-6-824\"><a href=\"#MIT-6-824\" class=\"headerlink\" title=\"MIT 6.824\"></a>MIT 6.824</h2><p>MIT 6.824是一个关于分布式算法的公开课，一般和数据库内核相关的课程一起学习（例如CMU15-445）,这个课的完整视频可以在<a href=\"https://www.bilibili.com/video/BV1R7411t71W/?p=2&vd_source=38ddec4d9f5d5a36fb2df2883f091000\">这里</a>看到。</p>\n<p>我并没有把这个课程看完，我的重点在于这个课程的第二个Lab，用Go语言做了一个Raft，这是入门Raft的一个好材料，该Lab的地址在<a href=\"http://nil.csail.mit.edu/6.824/2022/labs/lab-raft.html\">这里</a>，提交作业的地址在<a href=\"https://6824.scripts.mit.edu/2022/handin.py\">这里</a></p>\n<p>由于时间关系，我也没有把这个实验做完，只做了前两部，即：选举和日志同步，我的代码在：<a href=\"https://github.com/eddyli1989/6.824\">https://github.com/eddyli1989/6.824</a><br>我不建议你直接看答案</p>\n<p>下面是一些大方向之类的建议：</p>\n<ul>\n<li>在自己动手编写之前，不建议你在网上看别人的答案</li>\n<li>不要着急写代码，在写代码之前先想好程序的主要结构是什么样子，需要什么数据结构，如何驱动整个程序，甚至每个场景下应该如何处理，都先想好，如果实在想不出来，可以画流程图</li>\n<li>搞清楚每个状态下的每个变量是干啥用的，否则你只能在一次次莫名其妙的失败中去定位，非常消耗时间</li>\n</ul>\n<h2 id=\"选举阶段\"><a href=\"#选举阶段\" class=\"headerlink\" title=\"选举阶段\"></a>选举阶段</h2><ul>\n<li>在实现选举阶段之前，你需要先明确整个程序的运行框架，整个程序基于一个定时器不停的循环，需要新增一个Role变量，用来保存当前的角色，然后再定时器中根据角色的不同，进入不同的函数，这是程序的大框架</li>\n<li>确定选举定时器的超时时间，以及随机的时间范围，论文中建议为150-300ms，实际可能需要比这个时间更大，经过多次尝试，这个时间我最终选择了300~450ms</li>\n<li>随机数的选择，不要用rand，rand是假随机数，会导致几乎每次随机得到的时间都是固定的，会出现如下情况：当有2<del>3个节点，而这2</del>3个节点中，哪个节点满足成为Leader的条件是固定的，但是由于假随机数导致，该节点的定时器总是晚于其他节点，从而导致该节点一直无法赢得选举(瓜分选票，即：每个节点都投票给自己)，这种情况最终会导致用例的失败，因此我选择了crypto&#x2F;rand.</li>\n<li>在第一个2A作业中，你不需要在RequestVote请求里对比日志，这个是2B的部分</li>\n<li>每一个节点在每一个Term中，只能投一张票，注意，是每一个Term，所以如果在Term1投给自己，现在收到Term2的投票请求，你还是要投给别人</li>\n<li>注意加锁，且不要死锁，在跑test的时候加上-race参数，控制锁的粒度，不要在休眠的时候仍然持有锁</li>\n<li>在广播请求时，注意过滤掉自己</li>\n<li>在任何阶段，收到一个响应中的Term比自己的Term大，立即变为Folowwer</li>\n<li>本实验中的RPC为同步调用，即：在未收到响应前会阻塞，且网络被设定为不可靠，所以任何一个请求的时延可能是不固定的</li>\n<li>基于以上原因，建议采用gorouting+chan的异步方式对同步调用进行封装，否则比较难以进行下去</li>\n<li>如果接纳了别人的投票，那角色应该变为Folowwer</li>\n<li>在变为Leader以后，马上发送AppendEntries</li>\n</ul>\n<h2 id=\"日志同步\"><a href=\"#日志同步\" class=\"headerlink\" title=\"日志同步\"></a>日志同步</h2><ul>\n<li>在RequestVote里要判断谁的日志更新，注意：论文中对谁的日志更新有准确描述，不要臆测，并不是谁的日志越长谁的就更新</li>\n<li>Start接口在Leader把日志添加到自己的Log数组中就可以返回了，并不用等待同步给其他节点</li>\n<li>nextIndex的含义，指的是下次同步日志的时候，可以尝试从该索引同步，但并不保障一定能同步成功</li>\n<li>matchIndex的含义，是用来校准commitIndex的，如果大多数节点的matchIndex都大于某个数，那么commitIndex应该被设置为这个数字</li>\n<li>matchIndex决定了lastApplied，理论上lastApplied&lt;&#x3D;matchIndex</li>\n<li>应用到自动机的意思就是 构造一个ApplyMsg并把他送到applyCh，在当前场景下ApplyMsg的CommandValid应该被一直设置为true。在实际应用中，应用到自动机的意思应该是，针对该日志对数据做正式的修改，例如该日志是想set x &#x3D; 10，那么应用到自动机的含义应该就是把x这个key的值设置为10.</li>\n<li>AppendEntriesArgs中的LeaderCommit扮演了重要角色，他实际上是2PC中的第二阶段，因为LeaderCommit可以控制Folowwer节点的commitIndex，从而控制Folowwer节点的日志提交(lastApplied)，一般正常的流程是：主节点收到Start，然后通过日志同步到子节点，然后主节点提交该日志，并在下一次心跳时，将LeaderCommit带给子节点，然后子节点才会去提交该日志。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Raft-共识算法\"><a href=\"#Raft-共识算法\" class=\"headerlink\" title=\"Raft 共识算法\"></a>Raft 共识算法</h2><p>Raft是非常出名的一个共识算法，关于Raft的介绍网络上已经有很多帖子了，但我建议你还是直接看原版<a href=\"https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf\">论文</a>，如果英语不行，先看中文<a href=\"https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md\">翻译版</a></p>\n<p>了解的差不多了以后，基本上就要开始动手去写一个Raft了，这里推荐直接使用MIT 6.824的实验来做，比较容易上手，注意这个实验是使用Go语言做的，如果不熟悉Go语言，可以快速学习一下</p>\n<h2 id=\"MIT-6-824\"><a href=\"#MIT-6-824\" class=\"headerlink\" title=\"MIT 6.824\"></a>MIT 6.824</h2><p>MIT 6.824是一个关于分布式算法的公开课，一般和数据库内核相关的课程一起学习（例如CMU15-445）,这个课的完整视频可以在<a href=\"https://www.bilibili.com/video/BV1R7411t71W/?p=2&vd_source=38ddec4d9f5d5a36fb2df2883f091000\">这里</a>看到。</p>\n<p>我并没有把这个课程看完，我的重点在于这个课程的第二个Lab，用Go语言做了一个Raft，这是入门Raft的一个好材料，该Lab的地址在<a href=\"http://nil.csail.mit.edu/6.824/2022/labs/lab-raft.html\">这里</a>，提交作业的地址在<a href=\"https://6824.scripts.mit.edu/2022/handin.py\">这里</a></p>\n<p>由于时间关系，我也没有把这个实验做完，只做了前两部，即：选举和日志同步，我的代码在：<a href=\"https://github.com/eddyli1989/6.824\">https://github.com/eddyli1989/6.824</a><br>我不建议你直接看答案</p>\n<p>下面是一些大方向之类的建议：</p>\n<ul>\n<li>在自己动手编写之前，不建议你在网上看别人的答案</li>\n<li>不要着急写代码，在写代码之前先想好程序的主要结构是什么样子，需要什么数据结构，如何驱动整个程序，甚至每个场景下应该如何处理，都先想好，如果实在想不出来，可以画流程图</li>\n<li>搞清楚每个状态下的每个变量是干啥用的，否则你只能在一次次莫名其妙的失败中去定位，非常消耗时间</li>\n</ul>\n<h2 id=\"选举阶段\"><a href=\"#选举阶段\" class=\"headerlink\" title=\"选举阶段\"></a>选举阶段</h2><ul>\n<li>在实现选举阶段之前，你需要先明确整个程序的运行框架，整个程序基于一个定时器不停的循环，需要新增一个Role变量，用来保存当前的角色，然后再定时器中根据角色的不同，进入不同的函数，这是程序的大框架</li>\n<li>确定选举定时器的超时时间，以及随机的时间范围，论文中建议为150-300ms，实际可能需要比这个时间更大，经过多次尝试，这个时间我最终选择了300~450ms</li>\n<li>随机数的选择，不要用rand，rand是假随机数，会导致几乎每次随机得到的时间都是固定的，会出现如下情况：当有2<del>3个节点，而这2</del>3个节点中，哪个节点满足成为Leader的条件是固定的，但是由于假随机数导致，该节点的定时器总是晚于其他节点，从而导致该节点一直无法赢得选举(瓜分选票，即：每个节点都投票给自己)，这种情况最终会导致用例的失败，因此我选择了crypto&#x2F;rand.</li>\n<li>在第一个2A作业中，你不需要在RequestVote请求里对比日志，这个是2B的部分</li>\n<li>每一个节点在每一个Term中，只能投一张票，注意，是每一个Term，所以如果在Term1投给自己，现在收到Term2的投票请求，你还是要投给别人</li>\n<li>注意加锁，且不要死锁，在跑test的时候加上-race参数，控制锁的粒度，不要在休眠的时候仍然持有锁</li>\n<li>在广播请求时，注意过滤掉自己</li>\n<li>在任何阶段，收到一个响应中的Term比自己的Term大，立即变为Folowwer</li>\n<li>本实验中的RPC为同步调用，即：在未收到响应前会阻塞，且网络被设定为不可靠，所以任何一个请求的时延可能是不固定的</li>\n<li>基于以上原因，建议采用gorouting+chan的异步方式对同步调用进行封装，否则比较难以进行下去</li>\n<li>如果接纳了别人的投票，那角色应该变为Folowwer</li>\n<li>在变为Leader以后，马上发送AppendEntries</li>\n</ul>\n<h2 id=\"日志同步\"><a href=\"#日志同步\" class=\"headerlink\" title=\"日志同步\"></a>日志同步</h2><ul>\n<li>在RequestVote里要判断谁的日志更新，注意：论文中对谁的日志更新有准确描述，不要臆测，并不是谁的日志越长谁的就更新</li>\n<li>Start接口在Leader把日志添加到自己的Log数组中就可以返回了，并不用等待同步给其他节点</li>\n<li>nextIndex的含义，指的是下次同步日志的时候，可以尝试从该索引同步，但并不保障一定能同步成功</li>\n<li>matchIndex的含义，是用来校准commitIndex的，如果大多数节点的matchIndex都大于某个数，那么commitIndex应该被设置为这个数字</li>\n<li>matchIndex决定了lastApplied，理论上lastApplied&lt;&#x3D;matchIndex</li>\n<li>应用到自动机的意思就是 构造一个ApplyMsg并把他送到applyCh，在当前场景下ApplyMsg的CommandValid应该被一直设置为true。在实际应用中，应用到自动机的意思应该是，针对该日志对数据做正式的修改，例如该日志是想set x &#x3D; 10，那么应用到自动机的含义应该就是把x这个key的值设置为10.</li>\n<li>AppendEntriesArgs中的LeaderCommit扮演了重要角色，他实际上是2PC中的第二阶段，因为LeaderCommit可以控制Folowwer节点的commitIndex，从而控制Folowwer节点的日志提交(lastApplied)，一般正常的流程是：主节点收到Start，然后通过日志同步到子节点，然后主节点提交该日志，并在下一次心跳时，将LeaderCommit带给子节点，然后子节点才会去提交该日志。</li>\n</ul>\n"},{"title":"exit函数与僵尸进程","date":"2016-03-01T00:00:00.000Z","_content":"\n在UNIX中，有三个函数用于正常终止一个程序\n\n\n    #include<stdlib.h>\n    void exit(int status)\n    void _Exit(int status)\n\n    #include<unistd.h>\n    void _exit(int status)\n\n其中前两个是由ISO C说明，而第三个由POSIX.1说明，也就是说前两个是库函数，而第三个是系统调用。\nexit函数总是会执行一个标准I/O库的清理关闭工作，为所有打开的流调用fclose函数，这会造成所有的缓冲的输出数据都被冲洗.\n这三个函数的参数都代表了当前进程的终止状态。\n\n当然，进程也可能以非正常状态终止。比如收到一个SIGABRT信号等。\n\n不管进程是如何终止的，内核都会为进程进行一些清理工作，关闭文件描述符，释放存储器等。\n\n不论任何情况，父进程都应该能够知道子进程是如何终止的，这可以通过调用wait或waitpid函数取得其终止状态等信息。\n\n如果子进程没终止，父进程先终止了，会怎样呢？init进程会“领养”这些子进程，这种方法保证每个进程都有一个父进程。\n\n如果子进程终止了，父进程没终止呢？内核必须还为该进程保存一些信息，因为父进程有可能会需要这些信息，这些信息包括进程ID，终止状态，CPU时间总量等，但是终止的子进程中的文件描述符和内存均已释放\n\n> UNIX术语中，一个已经终止，但父进程没有对其进行善后处理(获取子进程的相关信息)称为僵死进程。\n\n避免出现僵死进程的方法是，调用wait或者waitpid函数取得子进程终止状态，或将SIGCHLD信号忽略。\n被init进程领养的子进程不会变为僵尸进程，init会逐一调用wait取得其终止状态。\n","source":"_posts/exit函数与僵尸进程.md","raw":"---\ntitle: \"exit函数与僵尸进程\"\ndate: \"2016-02-30\"\ntags: [exit, 僵尸进程]\n---\n\n在UNIX中，有三个函数用于正常终止一个程序\n\n\n    #include<stdlib.h>\n    void exit(int status)\n    void _Exit(int status)\n\n    #include<unistd.h>\n    void _exit(int status)\n\n其中前两个是由ISO C说明，而第三个由POSIX.1说明，也就是说前两个是库函数，而第三个是系统调用。\nexit函数总是会执行一个标准I/O库的清理关闭工作，为所有打开的流调用fclose函数，这会造成所有的缓冲的输出数据都被冲洗.\n这三个函数的参数都代表了当前进程的终止状态。\n\n当然，进程也可能以非正常状态终止。比如收到一个SIGABRT信号等。\n\n不管进程是如何终止的，内核都会为进程进行一些清理工作，关闭文件描述符，释放存储器等。\n\n不论任何情况，父进程都应该能够知道子进程是如何终止的，这可以通过调用wait或waitpid函数取得其终止状态等信息。\n\n如果子进程没终止，父进程先终止了，会怎样呢？init进程会“领养”这些子进程，这种方法保证每个进程都有一个父进程。\n\n如果子进程终止了，父进程没终止呢？内核必须还为该进程保存一些信息，因为父进程有可能会需要这些信息，这些信息包括进程ID，终止状态，CPU时间总量等，但是终止的子进程中的文件描述符和内存均已释放\n\n> UNIX术语中，一个已经终止，但父进程没有对其进行善后处理(获取子进程的相关信息)称为僵死进程。\n\n避免出现僵死进程的方法是，调用wait或者waitpid函数取得子进程终止状态，或将SIGCHLD信号忽略。\n被init进程领养的子进程不会变为僵尸进程，init会逐一调用wait取得其终止状态。\n","slug":"exit函数与僵尸进程","published":1,"updated":"2023-04-15T08:57:13.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clghs86k40003sgvi57u2hzx2","content":"<p>在UNIX中，有三个函数用于正常终止一个程序</p>\n<pre><code>#include&lt;stdlib.h&gt;\nvoid exit(int status)\nvoid _Exit(int status)\n\n#include&lt;unistd.h&gt;\nvoid _exit(int status)\n</code></pre>\n<p>其中前两个是由ISO C说明，而第三个由POSIX.1说明，也就是说前两个是库函数，而第三个是系统调用。<br>exit函数总是会执行一个标准I&#x2F;O库的清理关闭工作，为所有打开的流调用fclose函数，这会造成所有的缓冲的输出数据都被冲洗.<br>这三个函数的参数都代表了当前进程的终止状态。</p>\n<p>当然，进程也可能以非正常状态终止。比如收到一个SIGABRT信号等。</p>\n<p>不管进程是如何终止的，内核都会为进程进行一些清理工作，关闭文件描述符，释放存储器等。</p>\n<p>不论任何情况，父进程都应该能够知道子进程是如何终止的，这可以通过调用wait或waitpid函数取得其终止状态等信息。</p>\n<p>如果子进程没终止，父进程先终止了，会怎样呢？init进程会“领养”这些子进程，这种方法保证每个进程都有一个父进程。</p>\n<p>如果子进程终止了，父进程没终止呢？内核必须还为该进程保存一些信息，因为父进程有可能会需要这些信息，这些信息包括进程ID，终止状态，CPU时间总量等，但是终止的子进程中的文件描述符和内存均已释放</p>\n<blockquote>\n<p>UNIX术语中，一个已经终止，但父进程没有对其进行善后处理(获取子进程的相关信息)称为僵死进程。</p>\n</blockquote>\n<p>避免出现僵死进程的方法是，调用wait或者waitpid函数取得子进程终止状态，或将SIGCHLD信号忽略。<br>被init进程领养的子进程不会变为僵尸进程，init会逐一调用wait取得其终止状态。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在UNIX中，有三个函数用于正常终止一个程序</p>\n<pre><code>#include&lt;stdlib.h&gt;\nvoid exit(int status)\nvoid _Exit(int status)\n\n#include&lt;unistd.h&gt;\nvoid _exit(int status)\n</code></pre>\n<p>其中前两个是由ISO C说明，而第三个由POSIX.1说明，也就是说前两个是库函数，而第三个是系统调用。<br>exit函数总是会执行一个标准I&#x2F;O库的清理关闭工作，为所有打开的流调用fclose函数，这会造成所有的缓冲的输出数据都被冲洗.<br>这三个函数的参数都代表了当前进程的终止状态。</p>\n<p>当然，进程也可能以非正常状态终止。比如收到一个SIGABRT信号等。</p>\n<p>不管进程是如何终止的，内核都会为进程进行一些清理工作，关闭文件描述符，释放存储器等。</p>\n<p>不论任何情况，父进程都应该能够知道子进程是如何终止的，这可以通过调用wait或waitpid函数取得其终止状态等信息。</p>\n<p>如果子进程没终止，父进程先终止了，会怎样呢？init进程会“领养”这些子进程，这种方法保证每个进程都有一个父进程。</p>\n<p>如果子进程终止了，父进程没终止呢？内核必须还为该进程保存一些信息，因为父进程有可能会需要这些信息，这些信息包括进程ID，终止状态，CPU时间总量等，但是终止的子进程中的文件描述符和内存均已释放</p>\n<blockquote>\n<p>UNIX术语中，一个已经终止，但父进程没有对其进行善后处理(获取子进程的相关信息)称为僵死进程。</p>\n</blockquote>\n<p>避免出现僵死进程的方法是，调用wait或者waitpid函数取得子进程终止状态，或将SIGCHLD信号忽略。<br>被init进程领养的子进程不会变为僵尸进程，init会逐一调用wait取得其终止状态。</p>\n"},{"title":"A plain english introduction to CAP Theorem","date":"2017-03-30T00:00:00.000Z","_content":"\n<div id=\"post\">\n\n<p>You’ll often hear about the <span class=\"caps\">CAP</span> theorem which specifies some kind of an upper limit when designing distributed systems. As with most of my other introduction tutorials, lets try understanding <span class=\"caps\">CAP</span> by comparing it with a real world situation.</p>\n<h2>Chapter 1: “Remembrance Inc” Your new venture :</h2>\n<p>Last night when your spouse appreciated you on remembering her birthday and bringing her a gift, a strange Idea strikes you. People are so bad in remembering things. And you’re sooo good at it. So why not start a venture that will put your talent to use? The more you think about it, the more you like it. In fact you even come up with a news paper ad which explains your idea</p>\n<pre>Remembrance Inc! - Never forget,  even without remembering!\n   Ever felt bad that you forget so much?  Don't worry. Help is just a phone away!\n    When you need to remember something, just call 555--55-REMEM and tell us what you need to remember. For eg., call us and let us know of your boss's phone number, and forget to remember it. when you need to know it back.. call back the same number[(555)--55-REMEM ] and we'll tell you what's your boss's phone number.\n   Charges : only $0.1 per request</pre>\n<p>So, your typical phone conversation will look like this:</p>\n<ul>\n\t<li>Customer : Hey, Can you store my neighbor’s birthday?</li>\n\t<li>You: Sure.. when is it?</li>\n\t<li>Customer : 2nd of jan</li>\n\t<li>You: (write it down against the customer’s page in your paper note book )Stored. Call us any time for knowing your neighbor’s birthday again!</li>\n\t<li>Customer : Thank you!</li>\n\t<li>You: No problem! We charged your credit card with $0.1<br>\n&nbsp;</li>\n</ul>\n<h2>Chapter 2 : You scale up:</h2>\n<p>Your venture gets funded by YCombinator. Your Idea is so simple, needs nothing but a paper notebook and phone, yet so effective that it spreads like wild fire. You start getting hundreds of call every day.</p>\n<p>And there starts the problem. You see that more and more of your customers have to wait in the queue to speak to you. Most of them even hang up tired of the waiting tone. Besides when you were sick the other day and could not come to work you lost a whole day of business. Not to mention all those dissatisfied customers who wanted information on that day.<br>\nYou decide it’s time for you to scale up and bring in your wife to help you.</p>\n<p>Your start with a simple plan:</p>\n<ol>\n\t<li>You and your wife both get an extension phone</li>\n\t<li>Customers still dial (555)–55-<span class=\"caps\">REMEM</span> and need to remember only one number</li>\n\t<li>A pbx will route the a customers call to whoever is free and equally<br>\n&nbsp;</li>\n</ol>\n<h2>Chapter 3 : You have your first “Bad Service” :</h2>\n<p>Two days after you implemented the new system, you get a call from you get a call from your trusted customer Jhon. This is how it goes:</p>\n<ul>\n\t<li>Jhon: Hey</li>\n\t<li>You: Glad you called “Remembrance Inc!”. What can I do for you?</li>\n\t<li>Jhon: Can you tell me when is my flight to New Delhi?</li>\n\t<li>You: Sure.. 1 sec sir<br>\n(You look up your notebook)<br>\n(wow! there is no entry for “flight date” in Jhon’s page)!!!!!</li>\n\t<li>You: Sir, I think there is a mistake. You never told us about your flight to delhi</li>\n\t<li>Jhon: What! I just called you guys yesterday!(cuts the call!)</li>\n</ul>\n<p>How did that happen? Could Jhon be lying? You think about it for a second and the reason hits you! Could Jhon’s call yesterday reached your wife? You go to your wife’s desk and check her notebook. Sure enough it’s there. You tell this to your wife and she realizes the problem too.</p>\n<p>What a terrible flaw in your distributed design! <strong>Your distributed system is not consistent! There could always be a chance that a customer updates something which goes to either you or your wife and when the next call from the customer is routed to another person there will not be a consistent reply from Remembrance Inc!</strong><br>\n&nbsp;</p>\n<h2>Chapter 4: You fix the Consistency problem:</h2>\n<p>Well, your competitors may ignore a bad service, but not you. You think all night in the bed when your wife is sleeping and come up with a beautiful plan in the morning. You wake up your wife and tell her:</p>\n<p>” Darling this is what we are going to do from now”</p>\n<ul>\n\t<li>Whenever any one of us get a call for an update(when the customer wants us to remember something) before completing the call we tell the other person</li>\n\t<li>This way both of us note down any updates</li>\n\t<li>When there is call for search(When the customer wants information he has already stored) we don’t need to talk with the other person. Since both of us have the latest updated information in both of our note books we can just refer to it..</li>\n</ul>\n<p>There is only one problem though, you say, and that is an “update” request has to involve both of us and we cannot work in parallel during that time. For eg. when you get an update request and telling me to update too, i cannot take other calls. But that’s okay because most calls we get anyway are “search” (a customer updates once and asks many times) . Besides, we cannot give wrong information at any cost.</p>\n<p>“Neat” your wife says, “but there is one more flaw in this system that you haven’t thought of. What if one of us doesn’t report to work on a particular day? On that day, then, we won’t be able to take “any” Update calls, because the other person cannot be updated! We will have <strong>Availability problem , i.e, for eg., if an update request comes to me I will never be able to complete that call because even though I have written the update in my note book, I can never update you. So I can never complete the call!”</strong><br>\n&nbsp;</p>\n<h2>Chapter 5: You come up with the greatest solution Ever:</h2>\n<p>You being to realize a little bit on why distributed system might not be as easy as you thought at first. Is it that difficult to come up with a solution that could be both <strong>“Consistent and Available”</strong>? Could be difficult for others, but not for you!! Then next morning you come up with a solution that your competitors cannot think of in their dreams! You wake your wife up eagerly again..</p>\n<p>” look” , you tell her.. “This is what we can do to be consistent and available” . The plan is mostly similar to what I told you yesterday:</p>\n<ul>\n\t<li>i) Whenever any one of us get a call for an update(when the customer wants us to remember something) before completing the call, if the other person is available we tell the other person. This way both of us note down any updates</li>\n\t<li>ii) But if the other person is not available(doesn’t report to work) we send the other person an email about the update.</li>\n\t<li>iii) The next day when the other person comes to work after taking a day off, He first goes through all the emails, updates his note book accordingly.. before taking his first call.</li>\n</ul>\n<p>Genius! You wife says! I can’t find any flaws in this systems. Let’s put it to use.. Remembrance Inc! is now both <strong>Consistent and available!</strong><br>\n&nbsp;</p>\n<h2>Chapter 6: Your wife gets angry :</h2>\n<p>Everything goes well for a while. Your system is consistent. Your system works well even when one of you doesn’t report to work. But what if Both of you report to work and one of you doesn’t update the other person? Remember all those days you’ve been waking your wife up early with your Greatest-idea-ever-bullshit? * What if your wife decides to take calls but is too angry with you and decides not to update you for a day? Your idea totally breaks! Your idea so far is good for consistency and availability but is not Partition Tolerant!*<br>\nYou can decide to be partition tolerant by deciding not to take any calls until you patch up with your wife.. Then your system will not be “available” during that time…<br>\n&nbsp;</p>\n<h2>Chapter 7: Conclusion :</h2>\n<p>So Let’s look at <span class=\"caps\">CAP</span> Theorem now. Its states that, when you are designing a distributed system you can get cannot achieve all three of Consistency, Availability and Partition tolerance. You can pick only two of:</p>\n<ul>\n\t<li>Consistency: You customers, once they have updated information with you, will always get the most updated information when they call subsequently. No matter how quickly they call back</li>\n\t<li>Availability: Remembrance Inc will always be available for calls until any one of you(you or your wife) report to work.</li>\n\t<li>Partition Tolerance: Remembrance Inc will work even if there is a communication loss between you and your wife!<br>\n&nbsp;</li>\n</ul>\n<h2>Bonus : Eventual Consistency with a run around clerk :</h2>\n<p>Here is another food for thought. You can have a run around clerk, who will update other’s notebook when one of your’s or your wife’s note books is updated. The greatest benefit of this is that, he can work in background and one of your or your wife’s “update” doesn’t have to block, waiting for the other one to update. This is how many NoSql systems work, one node updates itself locally and a background process synchronizes all other nodes accordingly… The only problem is that you will lose consistency of some time. For eg., a customer’s call reaches your wife first and before the clerk has a chance to update your notebook , the customer’ calls back and it reaches you. Then he won’t get a consistent reply.. But that said, this is not at all a bad idea if such cases are limited. For eg., assuming a customer won’t forget things so quickly that he calls back in 5 minutes.</p>\n<p>That’s <span class=\"caps\">CAP</span> and eventual consistency for you in simple english :)</p> \n</div>\n","source":"_posts/A plain english introduction to CAP Theorem.md","raw":"---\ntitle: \"A plain english introduction to CAP Theorem\"\ndate: \"2017-03-30\"\ntags: [CAP Theorem]\n---\n\n<div id=\"post\">\n\n<p>You’ll often hear about the <span class=\"caps\">CAP</span> theorem which specifies some kind of an upper limit when designing distributed systems. As with most of my other introduction tutorials, lets try understanding <span class=\"caps\">CAP</span> by comparing it with a real world situation.</p>\n<h2>Chapter 1: “Remembrance Inc” Your new venture :</h2>\n<p>Last night when your spouse appreciated you on remembering her birthday and bringing her a gift, a strange Idea strikes you. People are so bad in remembering things. And you’re sooo good at it. So why not start a venture that will put your talent to use? The more you think about it, the more you like it. In fact you even come up with a news paper ad which explains your idea</p>\n<pre>Remembrance Inc! - Never forget,  even without remembering!\n   Ever felt bad that you forget so much?  Don't worry. Help is just a phone away!\n    When you need to remember something, just call 555--55-REMEM and tell us what you need to remember. For eg., call us and let us know of your boss's phone number, and forget to remember it. when you need to know it back.. call back the same number[(555)--55-REMEM ] and we'll tell you what's your boss's phone number.\n   Charges : only $0.1 per request</pre>\n<p>So, your typical phone conversation will look like this:</p>\n<ul>\n\t<li>Customer : Hey, Can you store my neighbor’s birthday?</li>\n\t<li>You: Sure.. when is it?</li>\n\t<li>Customer : 2nd of jan</li>\n\t<li>You: (write it down against the customer’s page in your paper note book )Stored. Call us any time for knowing your neighbor’s birthday again!</li>\n\t<li>Customer : Thank you!</li>\n\t<li>You: No problem! We charged your credit card with $0.1<br>\n&nbsp;</li>\n</ul>\n<h2>Chapter 2 : You scale up:</h2>\n<p>Your venture gets funded by YCombinator. Your Idea is so simple, needs nothing but a paper notebook and phone, yet so effective that it spreads like wild fire. You start getting hundreds of call every day.</p>\n<p>And there starts the problem. You see that more and more of your customers have to wait in the queue to speak to you. Most of them even hang up tired of the waiting tone. Besides when you were sick the other day and could not come to work you lost a whole day of business. Not to mention all those dissatisfied customers who wanted information on that day.<br>\nYou decide it’s time for you to scale up and bring in your wife to help you.</p>\n<p>Your start with a simple plan:</p>\n<ol>\n\t<li>You and your wife both get an extension phone</li>\n\t<li>Customers still dial (555)–55-<span class=\"caps\">REMEM</span> and need to remember only one number</li>\n\t<li>A pbx will route the a customers call to whoever is free and equally<br>\n&nbsp;</li>\n</ol>\n<h2>Chapter 3 : You have your first “Bad Service” :</h2>\n<p>Two days after you implemented the new system, you get a call from you get a call from your trusted customer Jhon. This is how it goes:</p>\n<ul>\n\t<li>Jhon: Hey</li>\n\t<li>You: Glad you called “Remembrance Inc!”. What can I do for you?</li>\n\t<li>Jhon: Can you tell me when is my flight to New Delhi?</li>\n\t<li>You: Sure.. 1 sec sir<br>\n(You look up your notebook)<br>\n(wow! there is no entry for “flight date” in Jhon’s page)!!!!!</li>\n\t<li>You: Sir, I think there is a mistake. You never told us about your flight to delhi</li>\n\t<li>Jhon: What! I just called you guys yesterday!(cuts the call!)</li>\n</ul>\n<p>How did that happen? Could Jhon be lying? You think about it for a second and the reason hits you! Could Jhon’s call yesterday reached your wife? You go to your wife’s desk and check her notebook. Sure enough it’s there. You tell this to your wife and she realizes the problem too.</p>\n<p>What a terrible flaw in your distributed design! <strong>Your distributed system is not consistent! There could always be a chance that a customer updates something which goes to either you or your wife and when the next call from the customer is routed to another person there will not be a consistent reply from Remembrance Inc!</strong><br>\n&nbsp;</p>\n<h2>Chapter 4: You fix the Consistency problem:</h2>\n<p>Well, your competitors may ignore a bad service, but not you. You think all night in the bed when your wife is sleeping and come up with a beautiful plan in the morning. You wake up your wife and tell her:</p>\n<p>” Darling this is what we are going to do from now”</p>\n<ul>\n\t<li>Whenever any one of us get a call for an update(when the customer wants us to remember something) before completing the call we tell the other person</li>\n\t<li>This way both of us note down any updates</li>\n\t<li>When there is call for search(When the customer wants information he has already stored) we don’t need to talk with the other person. Since both of us have the latest updated information in both of our note books we can just refer to it..</li>\n</ul>\n<p>There is only one problem though, you say, and that is an “update” request has to involve both of us and we cannot work in parallel during that time. For eg. when you get an update request and telling me to update too, i cannot take other calls. But that’s okay because most calls we get anyway are “search” (a customer updates once and asks many times) . Besides, we cannot give wrong information at any cost.</p>\n<p>“Neat” your wife says, “but there is one more flaw in this system that you haven’t thought of. What if one of us doesn’t report to work on a particular day? On that day, then, we won’t be able to take “any” Update calls, because the other person cannot be updated! We will have <strong>Availability problem , i.e, for eg., if an update request comes to me I will never be able to complete that call because even though I have written the update in my note book, I can never update you. So I can never complete the call!”</strong><br>\n&nbsp;</p>\n<h2>Chapter 5: You come up with the greatest solution Ever:</h2>\n<p>You being to realize a little bit on why distributed system might not be as easy as you thought at first. Is it that difficult to come up with a solution that could be both <strong>“Consistent and Available”</strong>? Could be difficult for others, but not for you!! Then next morning you come up with a solution that your competitors cannot think of in their dreams! You wake your wife up eagerly again..</p>\n<p>” look” , you tell her.. “This is what we can do to be consistent and available” . The plan is mostly similar to what I told you yesterday:</p>\n<ul>\n\t<li>i) Whenever any one of us get a call for an update(when the customer wants us to remember something) before completing the call, if the other person is available we tell the other person. This way both of us note down any updates</li>\n\t<li>ii) But if the other person is not available(doesn’t report to work) we send the other person an email about the update.</li>\n\t<li>iii) The next day when the other person comes to work after taking a day off, He first goes through all the emails, updates his note book accordingly.. before taking his first call.</li>\n</ul>\n<p>Genius! You wife says! I can’t find any flaws in this systems. Let’s put it to use.. Remembrance Inc! is now both <strong>Consistent and available!</strong><br>\n&nbsp;</p>\n<h2>Chapter 6: Your wife gets angry :</h2>\n<p>Everything goes well for a while. Your system is consistent. Your system works well even when one of you doesn’t report to work. But what if Both of you report to work and one of you doesn’t update the other person? Remember all those days you’ve been waking your wife up early with your Greatest-idea-ever-bullshit? * What if your wife decides to take calls but is too angry with you and decides not to update you for a day? Your idea totally breaks! Your idea so far is good for consistency and availability but is not Partition Tolerant!*<br>\nYou can decide to be partition tolerant by deciding not to take any calls until you patch up with your wife.. Then your system will not be “available” during that time…<br>\n&nbsp;</p>\n<h2>Chapter 7: Conclusion :</h2>\n<p>So Let’s look at <span class=\"caps\">CAP</span> Theorem now. Its states that, when you are designing a distributed system you can get cannot achieve all three of Consistency, Availability and Partition tolerance. You can pick only two of:</p>\n<ul>\n\t<li>Consistency: You customers, once they have updated information with you, will always get the most updated information when they call subsequently. No matter how quickly they call back</li>\n\t<li>Availability: Remembrance Inc will always be available for calls until any one of you(you or your wife) report to work.</li>\n\t<li>Partition Tolerance: Remembrance Inc will work even if there is a communication loss between you and your wife!<br>\n&nbsp;</li>\n</ul>\n<h2>Bonus : Eventual Consistency with a run around clerk :</h2>\n<p>Here is another food for thought. You can have a run around clerk, who will update other’s notebook when one of your’s or your wife’s note books is updated. The greatest benefit of this is that, he can work in background and one of your or your wife’s “update” doesn’t have to block, waiting for the other one to update. This is how many NoSql systems work, one node updates itself locally and a background process synchronizes all other nodes accordingly… The only problem is that you will lose consistency of some time. For eg., a customer’s call reaches your wife first and before the clerk has a chance to update your notebook , the customer’ calls back and it reaches you. Then he won’t get a consistent reply.. But that said, this is not at all a bad idea if such cases are limited. For eg., assuming a customer won’t forget things so quickly that he calls back in 5 minutes.</p>\n<p>That’s <span class=\"caps\">CAP</span> and eventual consistency for you in simple english :)</p> \n</div>\n","slug":"A plain english introduction to CAP Theorem","published":1,"updated":"2023-04-15T08:57:13.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clghs86k50004sgvi8lhs2ryg","content":"<div id=\"post\">\n\n<p>You’ll often hear about the <span class=\"caps\">CAP</span> theorem which specifies some kind of an upper limit when designing distributed systems. As with most of my other introduction tutorials, lets try understanding <span class=\"caps\">CAP</span> by comparing it with a real world situation.</p>\n<h2>Chapter 1: “Remembrance Inc” Your new venture :</h2>\n<p>Last night when your spouse appreciated you on remembering her birthday and bringing her a gift, a strange Idea strikes you. People are so bad in remembering things. And you’re sooo good at it. So why not start a venture that will put your talent to use? The more you think about it, the more you like it. In fact you even come up with a news paper ad which explains your idea</p>\n<pre>Remembrance Inc! - Never forget,  even without remembering!\n   Ever felt bad that you forget so much?  Don't worry. Help is just a phone away!\n    When you need to remember something, just call 555--55-REMEM and tell us what you need to remember. For eg., call us and let us know of your boss's phone number, and forget to remember it. when you need to know it back.. call back the same number[(555)--55-REMEM ] and we'll tell you what's your boss's phone number.\n   Charges : only $0.1 per request</pre>\n<p>So, your typical phone conversation will look like this:</p>\n<ul>\n    <li>Customer : Hey, Can you store my neighbor’s birthday?</li>\n    <li>You: Sure.. when is it?</li>\n    <li>Customer : 2nd of jan</li>\n    <li>You: (write it down against the customer’s page in your paper note book )Stored. Call us any time for knowing your neighbor’s birthday again!</li>\n    <li>Customer : Thank you!</li>\n    <li>You: No problem! We charged your credit card with $0.1<br>\n&nbsp;</li>\n</ul>\n<h2>Chapter 2 : You scale up:</h2>\n<p>Your venture gets funded by YCombinator. Your Idea is so simple, needs nothing but a paper notebook and phone, yet so effective that it spreads like wild fire. You start getting hundreds of call every day.</p>\n<p>And there starts the problem. You see that more and more of your customers have to wait in the queue to speak to you. Most of them even hang up tired of the waiting tone. Besides when you were sick the other day and could not come to work you lost a whole day of business. Not to mention all those dissatisfied customers who wanted information on that day.<br>\nYou decide it’s time for you to scale up and bring in your wife to help you.</p>\n<p>Your start with a simple plan:</p>\n<ol>\n    <li>You and your wife both get an extension phone</li>\n    <li>Customers still dial (555)–55-<span class=\"caps\">REMEM</span> and need to remember only one number</li>\n    <li>A pbx will route the a customers call to whoever is free and equally<br>\n&nbsp;</li>\n</ol>\n<h2>Chapter 3 : You have your first “Bad Service” :</h2>\n<p>Two days after you implemented the new system, you get a call from you get a call from your trusted customer Jhon. This is how it goes:</p>\n<ul>\n    <li>Jhon: Hey</li>\n    <li>You: Glad you called “Remembrance Inc!”. What can I do for you?</li>\n    <li>Jhon: Can you tell me when is my flight to New Delhi?</li>\n    <li>You: Sure.. 1 sec sir<br>\n(You look up your notebook)<br>\n(wow! there is no entry for “flight date” in Jhon’s page)!!!!!</li>\n    <li>You: Sir, I think there is a mistake. You never told us about your flight to delhi</li>\n    <li>Jhon: What! I just called you guys yesterday!(cuts the call!)</li>\n</ul>\n<p>How did that happen? Could Jhon be lying? You think about it for a second and the reason hits you! Could Jhon’s call yesterday reached your wife? You go to your wife’s desk and check her notebook. Sure enough it’s there. You tell this to your wife and she realizes the problem too.</p>\n<p>What a terrible flaw in your distributed design! <strong>Your distributed system is not consistent! There could always be a chance that a customer updates something which goes to either you or your wife and when the next call from the customer is routed to another person there will not be a consistent reply from Remembrance Inc!</strong><br>\n&nbsp;</p>\n<h2>Chapter 4: You fix the Consistency problem:</h2>\n<p>Well, your competitors may ignore a bad service, but not you. You think all night in the bed when your wife is sleeping and come up with a beautiful plan in the morning. You wake up your wife and tell her:</p>\n<p>” Darling this is what we are going to do from now”</p>\n<ul>\n    <li>Whenever any one of us get a call for an update(when the customer wants us to remember something) before completing the call we tell the other person</li>\n    <li>This way both of us note down any updates</li>\n    <li>When there is call for search(When the customer wants information he has already stored) we don’t need to talk with the other person. Since both of us have the latest updated information in both of our note books we can just refer to it..</li>\n</ul>\n<p>There is only one problem though, you say, and that is an “update” request has to involve both of us and we cannot work in parallel during that time. For eg. when you get an update request and telling me to update too, i cannot take other calls. But that’s okay because most calls we get anyway are “search” (a customer updates once and asks many times) . Besides, we cannot give wrong information at any cost.</p>\n<p>“Neat” your wife says, “but there is one more flaw in this system that you haven’t thought of. What if one of us doesn’t report to work on a particular day? On that day, then, we won’t be able to take “any” Update calls, because the other person cannot be updated! We will have <strong>Availability problem , i.e, for eg., if an update request comes to me I will never be able to complete that call because even though I have written the update in my note book, I can never update you. So I can never complete the call!”</strong><br>\n&nbsp;</p>\n<h2>Chapter 5: You come up with the greatest solution Ever:</h2>\n<p>You being to realize a little bit on why distributed system might not be as easy as you thought at first. Is it that difficult to come up with a solution that could be both <strong>“Consistent and Available”</strong>? Could be difficult for others, but not for you!! Then next morning you come up with a solution that your competitors cannot think of in their dreams! You wake your wife up eagerly again..</p>\n<p>” look” , you tell her.. “This is what we can do to be consistent and available” . The plan is mostly similar to what I told you yesterday:</p>\n<ul>\n    <li>i) Whenever any one of us get a call for an update(when the customer wants us to remember something) before completing the call, if the other person is available we tell the other person. This way both of us note down any updates</li>\n    <li>ii) But if the other person is not available(doesn’t report to work) we send the other person an email about the update.</li>\n    <li>iii) The next day when the other person comes to work after taking a day off, He first goes through all the emails, updates his note book accordingly.. before taking his first call.</li>\n</ul>\n<p>Genius! You wife says! I can’t find any flaws in this systems. Let’s put it to use.. Remembrance Inc! is now both <strong>Consistent and available!</strong><br>\n&nbsp;</p>\n<h2>Chapter 6: Your wife gets angry :</h2>\n<p>Everything goes well for a while. Your system is consistent. Your system works well even when one of you doesn’t report to work. But what if Both of you report to work and one of you doesn’t update the other person? Remember all those days you’ve been waking your wife up early with your Greatest-idea-ever-bullshit? * What if your wife decides to take calls but is too angry with you and decides not to update you for a day? Your idea totally breaks! Your idea so far is good for consistency and availability but is not Partition Tolerant!*<br>\nYou can decide to be partition tolerant by deciding not to take any calls until you patch up with your wife.. Then your system will not be “available” during that time…<br>\n&nbsp;</p>\n<h2>Chapter 7: Conclusion :</h2>\n<p>So Let’s look at <span class=\"caps\">CAP</span> Theorem now. Its states that, when you are designing a distributed system you can get cannot achieve all three of Consistency, Availability and Partition tolerance. You can pick only two of:</p>\n<ul>\n    <li>Consistency: You customers, once they have updated information with you, will always get the most updated information when they call subsequently. No matter how quickly they call back</li>\n    <li>Availability: Remembrance Inc will always be available for calls until any one of you(you or your wife) report to work.</li>\n    <li>Partition Tolerance: Remembrance Inc will work even if there is a communication loss between you and your wife!<br>\n&nbsp;</li>\n</ul>\n<h2>Bonus : Eventual Consistency with a run around clerk :</h2>\n<p>Here is another food for thought. You can have a run around clerk, who will update other’s notebook when one of your’s or your wife’s note books is updated. The greatest benefit of this is that, he can work in background and one of your or your wife’s “update” doesn’t have to block, waiting for the other one to update. This is how many NoSql systems work, one node updates itself locally and a background process synchronizes all other nodes accordingly… The only problem is that you will lose consistency of some time. For eg., a customer’s call reaches your wife first and before the clerk has a chance to update your notebook , the customer’ calls back and it reaches you. Then he won’t get a consistent reply.. But that said, this is not at all a bad idea if such cases are limited. For eg., assuming a customer won’t forget things so quickly that he calls back in 5 minutes.</p>\n<p>That’s <span class=\"caps\">CAP</span> and eventual consistency for you in simple english :)</p> \n</div>\n","site":{"data":{}},"excerpt":"","more":"<div id=\"post\">\n\n<p>You’ll often hear about the <span class=\"caps\">CAP</span> theorem which specifies some kind of an upper limit when designing distributed systems. As with most of my other introduction tutorials, lets try understanding <span class=\"caps\">CAP</span> by comparing it with a real world situation.</p>\n<h2>Chapter 1: “Remembrance Inc” Your new venture :</h2>\n<p>Last night when your spouse appreciated you on remembering her birthday and bringing her a gift, a strange Idea strikes you. People are so bad in remembering things. And you’re sooo good at it. So why not start a venture that will put your talent to use? The more you think about it, the more you like it. In fact you even come up with a news paper ad which explains your idea</p>\n<pre>Remembrance Inc! - Never forget,  even without remembering!\n   Ever felt bad that you forget so much?  Don't worry. Help is just a phone away!\n    When you need to remember something, just call 555--55-REMEM and tell us what you need to remember. For eg., call us and let us know of your boss's phone number, and forget to remember it. when you need to know it back.. call back the same number[(555)--55-REMEM ] and we'll tell you what's your boss's phone number.\n   Charges : only $0.1 per request</pre>\n<p>So, your typical phone conversation will look like this:</p>\n<ul>\n    <li>Customer : Hey, Can you store my neighbor’s birthday?</li>\n    <li>You: Sure.. when is it?</li>\n    <li>Customer : 2nd of jan</li>\n    <li>You: (write it down against the customer’s page in your paper note book )Stored. Call us any time for knowing your neighbor’s birthday again!</li>\n    <li>Customer : Thank you!</li>\n    <li>You: No problem! We charged your credit card with $0.1<br>\n&nbsp;</li>\n</ul>\n<h2>Chapter 2 : You scale up:</h2>\n<p>Your venture gets funded by YCombinator. Your Idea is so simple, needs nothing but a paper notebook and phone, yet so effective that it spreads like wild fire. You start getting hundreds of call every day.</p>\n<p>And there starts the problem. You see that more and more of your customers have to wait in the queue to speak to you. Most of them even hang up tired of the waiting tone. Besides when you were sick the other day and could not come to work you lost a whole day of business. Not to mention all those dissatisfied customers who wanted information on that day.<br>\nYou decide it’s time for you to scale up and bring in your wife to help you.</p>\n<p>Your start with a simple plan:</p>\n<ol>\n    <li>You and your wife both get an extension phone</li>\n    <li>Customers still dial (555)–55-<span class=\"caps\">REMEM</span> and need to remember only one number</li>\n    <li>A pbx will route the a customers call to whoever is free and equally<br>\n&nbsp;</li>\n</ol>\n<h2>Chapter 3 : You have your first “Bad Service” :</h2>\n<p>Two days after you implemented the new system, you get a call from you get a call from your trusted customer Jhon. This is how it goes:</p>\n<ul>\n    <li>Jhon: Hey</li>\n    <li>You: Glad you called “Remembrance Inc!”. What can I do for you?</li>\n    <li>Jhon: Can you tell me when is my flight to New Delhi?</li>\n    <li>You: Sure.. 1 sec sir<br>\n(You look up your notebook)<br>\n(wow! there is no entry for “flight date” in Jhon’s page)!!!!!</li>\n    <li>You: Sir, I think there is a mistake. You never told us about your flight to delhi</li>\n    <li>Jhon: What! I just called you guys yesterday!(cuts the call!)</li>\n</ul>\n<p>How did that happen? Could Jhon be lying? You think about it for a second and the reason hits you! Could Jhon’s call yesterday reached your wife? You go to your wife’s desk and check her notebook. Sure enough it’s there. You tell this to your wife and she realizes the problem too.</p>\n<p>What a terrible flaw in your distributed design! <strong>Your distributed system is not consistent! There could always be a chance that a customer updates something which goes to either you or your wife and when the next call from the customer is routed to another person there will not be a consistent reply from Remembrance Inc!</strong><br>\n&nbsp;</p>\n<h2>Chapter 4: You fix the Consistency problem:</h2>\n<p>Well, your competitors may ignore a bad service, but not you. You think all night in the bed when your wife is sleeping and come up with a beautiful plan in the morning. You wake up your wife and tell her:</p>\n<p>” Darling this is what we are going to do from now”</p>\n<ul>\n    <li>Whenever any one of us get a call for an update(when the customer wants us to remember something) before completing the call we tell the other person</li>\n    <li>This way both of us note down any updates</li>\n    <li>When there is call for search(When the customer wants information he has already stored) we don’t need to talk with the other person. Since both of us have the latest updated information in both of our note books we can just refer to it..</li>\n</ul>\n<p>There is only one problem though, you say, and that is an “update” request has to involve both of us and we cannot work in parallel during that time. For eg. when you get an update request and telling me to update too, i cannot take other calls. But that’s okay because most calls we get anyway are “search” (a customer updates once and asks many times) . Besides, we cannot give wrong information at any cost.</p>\n<p>“Neat” your wife says, “but there is one more flaw in this system that you haven’t thought of. What if one of us doesn’t report to work on a particular day? On that day, then, we won’t be able to take “any” Update calls, because the other person cannot be updated! We will have <strong>Availability problem , i.e, for eg., if an update request comes to me I will never be able to complete that call because even though I have written the update in my note book, I can never update you. So I can never complete the call!”</strong><br>\n&nbsp;</p>\n<h2>Chapter 5: You come up with the greatest solution Ever:</h2>\n<p>You being to realize a little bit on why distributed system might not be as easy as you thought at first. Is it that difficult to come up with a solution that could be both <strong>“Consistent and Available”</strong>? Could be difficult for others, but not for you!! Then next morning you come up with a solution that your competitors cannot think of in their dreams! You wake your wife up eagerly again..</p>\n<p>” look” , you tell her.. “This is what we can do to be consistent and available” . The plan is mostly similar to what I told you yesterday:</p>\n<ul>\n    <li>i) Whenever any one of us get a call for an update(when the customer wants us to remember something) before completing the call, if the other person is available we tell the other person. This way both of us note down any updates</li>\n    <li>ii) But if the other person is not available(doesn’t report to work) we send the other person an email about the update.</li>\n    <li>iii) The next day when the other person comes to work after taking a day off, He first goes through all the emails, updates his note book accordingly.. before taking his first call.</li>\n</ul>\n<p>Genius! You wife says! I can’t find any flaws in this systems. Let’s put it to use.. Remembrance Inc! is now both <strong>Consistent and available!</strong><br>\n&nbsp;</p>\n<h2>Chapter 6: Your wife gets angry :</h2>\n<p>Everything goes well for a while. Your system is consistent. Your system works well even when one of you doesn’t report to work. But what if Both of you report to work and one of you doesn’t update the other person? Remember all those days you’ve been waking your wife up early with your Greatest-idea-ever-bullshit? * What if your wife decides to take calls but is too angry with you and decides not to update you for a day? Your idea totally breaks! Your idea so far is good for consistency and availability but is not Partition Tolerant!*<br>\nYou can decide to be partition tolerant by deciding not to take any calls until you patch up with your wife.. Then your system will not be “available” during that time…<br>\n&nbsp;</p>\n<h2>Chapter 7: Conclusion :</h2>\n<p>So Let’s look at <span class=\"caps\">CAP</span> Theorem now. Its states that, when you are designing a distributed system you can get cannot achieve all three of Consistency, Availability and Partition tolerance. You can pick only two of:</p>\n<ul>\n    <li>Consistency: You customers, once they have updated information with you, will always get the most updated information when they call subsequently. No matter how quickly they call back</li>\n    <li>Availability: Remembrance Inc will always be available for calls until any one of you(you or your wife) report to work.</li>\n    <li>Partition Tolerance: Remembrance Inc will work even if there is a communication loss between you and your wife!<br>\n&nbsp;</li>\n</ul>\n<h2>Bonus : Eventual Consistency with a run around clerk :</h2>\n<p>Here is another food for thought. You can have a run around clerk, who will update other’s notebook when one of your’s or your wife’s note books is updated. The greatest benefit of this is that, he can work in background and one of your or your wife’s “update” doesn’t have to block, waiting for the other one to update. This is how many NoSql systems work, one node updates itself locally and a background process synchronizes all other nodes accordingly… The only problem is that you will lose consistency of some time. For eg., a customer’s call reaches your wife first and before the clerk has a chance to update your notebook , the customer’ calls back and it reaches you. Then he won’t get a consistent reply.. But that said, this is not at all a bad idea if such cases are limited. For eg., assuming a customer won’t forget things so quickly that he calls back in 5 minutes.</p>\n<p>That’s <span class=\"caps\">CAP</span> and eventual consistency for you in simple english :)</p> \n</div>\n"},{"title":"动态连接和静态连接","date":"2016-03-30T00:00:00.000Z","_content":"\n一个库可以通过两种方式链接到程序中\n\n1、静态链接:使用链接器ld在编译链接的过程中直接将所有符号链接到2进制可执行文件中，在链接的过程中完成符号的重定位。\n\n2、动态链接:使用动态连接器(linux下叫做ld.x.x.x.so),在程序运行时动态加载所需要的符号，然后进行重定位，或者使用dlopen等函数进行显式运行时链接，这里有两种方式，即在程序运行时动态链接，或者使用dlopen进行实时的动态链接\n\n那么、动态库和静态库有什么本质的区别?为什么静态库不能被动态链接呢?\n\n其实，静态库从理论上来说也可以被动态链接到程序中去，只是静态库对于符号的描述中没有将符号描述为动态地址，操作系统的机制就是这样。\n\n**动态库也有两种实现方式**\n\n(1) 可重定位代码（relocatable code）：Windows DLL 以及不使用 -fPIC 的 Linux SO。 \n \n生成动态库时假定它被加载在地址 0 处。加载时它会被加载到一个地址（base），这时要进行一次重定位（relocation），把代码、数据段中所有的地址加上这个 base 的值。这样代码运行时就能使用正确的地址了。 \n \n(2) 位置无关代码（position independent code）：使用 -fPIC 的 Linux SO。 \n \n这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针（如 IA32 的 EIP 寄存器）的值，加上一个偏移得到全局变量/函数的地址。 \n \nPIC vs. relocatable： \n \n(1) PIC 的缺点主要就是代码有可能长一些。例如 IA32，由于不能直接使用 [EIP+constant] 这样的寻址方式，甚至不能直接将 EIP 的值交给其他寄存器，要用到 GOT（global offset table）来定位全局变量和函数。这样导致代码的效率略低。 \n \n(2) PIC 的加载速度稍快，因为不需要做重定位。 \n \n(3) 多个进程引用同一个 PIC 动态库时，可以共用内存。这一个库在不同进程中的虚拟地址不同，但操作系统显然会把它们映射到同一块物理内存上。对于可重定位代码，则必须为每个库都在物理内存中复制一份副本，因为需要修改其中的地址。当然，主流现代操作系统都启用了分页内存机制，这使得重定位时可以使用 COW（copy on write）来节省内存（32 位 Windows 就是这样做的）；然而，页面的粒度还是比较大的（例如 IA32 上是 4KiB），至少对于代码段来说能节省的相当有限。 \n\n**也就是说，地址无关代码能够真正做到共享代码段，而重定向的方式是无法做到共享代码段的，因为需要重定位代码，使用写时复制的特性可以做到某些情况下共享代码段**\n\n在 Linux 下制作动态链接库，“标准” 的做法是编译成位置无关代码（Position Independent Code，PIC），然后链接成一个动态链接库。经常遇到的一个问题是 -fPIC 是不是必需，因为好像不加经常也能正常运行，只是创建 .so 的时候会有一个警告。 \n \n(1) 通常的建议是始终加上 -fPIC 生成位置无关代码； \n \n(2) AMD64 下，必须使用位置无关代码，否则连接失败： \n \nrelocation R_X86_64_32S against `a local symbol' can not be used when making a shared object; recompile with -fPIC \n \n(3) IA32 下，连接成功，但有警告： \n \nwarning: creating a DT_TEXTREL in object. \n\n如果加上-fPIC那么就使用地址无关代码来实现动态链接，否则使用重定向的方式来实现\n","source":"_posts/动态连接和静态连接.md","raw":"---\ntitle: \"动态连接和静态连接\"\ndate: \"2016-03-30\"\ntags: [动态链接库]\n---\n\n一个库可以通过两种方式链接到程序中\n\n1、静态链接:使用链接器ld在编译链接的过程中直接将所有符号链接到2进制可执行文件中，在链接的过程中完成符号的重定位。\n\n2、动态链接:使用动态连接器(linux下叫做ld.x.x.x.so),在程序运行时动态加载所需要的符号，然后进行重定位，或者使用dlopen等函数进行显式运行时链接，这里有两种方式，即在程序运行时动态链接，或者使用dlopen进行实时的动态链接\n\n那么、动态库和静态库有什么本质的区别?为什么静态库不能被动态链接呢?\n\n其实，静态库从理论上来说也可以被动态链接到程序中去，只是静态库对于符号的描述中没有将符号描述为动态地址，操作系统的机制就是这样。\n\n**动态库也有两种实现方式**\n\n(1) 可重定位代码（relocatable code）：Windows DLL 以及不使用 -fPIC 的 Linux SO。 \n \n生成动态库时假定它被加载在地址 0 处。加载时它会被加载到一个地址（base），这时要进行一次重定位（relocation），把代码、数据段中所有的地址加上这个 base 的值。这样代码运行时就能使用正确的地址了。 \n \n(2) 位置无关代码（position independent code）：使用 -fPIC 的 Linux SO。 \n \n这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针（如 IA32 的 EIP 寄存器）的值，加上一个偏移得到全局变量/函数的地址。 \n \nPIC vs. relocatable： \n \n(1) PIC 的缺点主要就是代码有可能长一些。例如 IA32，由于不能直接使用 [EIP+constant] 这样的寻址方式，甚至不能直接将 EIP 的值交给其他寄存器，要用到 GOT（global offset table）来定位全局变量和函数。这样导致代码的效率略低。 \n \n(2) PIC 的加载速度稍快，因为不需要做重定位。 \n \n(3) 多个进程引用同一个 PIC 动态库时，可以共用内存。这一个库在不同进程中的虚拟地址不同，但操作系统显然会把它们映射到同一块物理内存上。对于可重定位代码，则必须为每个库都在物理内存中复制一份副本，因为需要修改其中的地址。当然，主流现代操作系统都启用了分页内存机制，这使得重定位时可以使用 COW（copy on write）来节省内存（32 位 Windows 就是这样做的）；然而，页面的粒度还是比较大的（例如 IA32 上是 4KiB），至少对于代码段来说能节省的相当有限。 \n\n**也就是说，地址无关代码能够真正做到共享代码段，而重定向的方式是无法做到共享代码段的，因为需要重定位代码，使用写时复制的特性可以做到某些情况下共享代码段**\n\n在 Linux 下制作动态链接库，“标准” 的做法是编译成位置无关代码（Position Independent Code，PIC），然后链接成一个动态链接库。经常遇到的一个问题是 -fPIC 是不是必需，因为好像不加经常也能正常运行，只是创建 .so 的时候会有一个警告。 \n \n(1) 通常的建议是始终加上 -fPIC 生成位置无关代码； \n \n(2) AMD64 下，必须使用位置无关代码，否则连接失败： \n \nrelocation R_X86_64_32S against `a local symbol' can not be used when making a shared object; recompile with -fPIC \n \n(3) IA32 下，连接成功，但有警告： \n \nwarning: creating a DT_TEXTREL in object. \n\n如果加上-fPIC那么就使用地址无关代码来实现动态链接，否则使用重定向的方式来实现\n","slug":"动态连接和静态连接","published":1,"updated":"2023-04-15T08:57:13.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clghs86k60007sgvi85ys6ets","content":"<p>一个库可以通过两种方式链接到程序中</p>\n<p>1、静态链接:使用链接器ld在编译链接的过程中直接将所有符号链接到2进制可执行文件中，在链接的过程中完成符号的重定位。</p>\n<p>2、动态链接:使用动态连接器(linux下叫做ld.x.x.x.so),在程序运行时动态加载所需要的符号，然后进行重定位，或者使用dlopen等函数进行显式运行时链接，这里有两种方式，即在程序运行时动态链接，或者使用dlopen进行实时的动态链接</p>\n<p>那么、动态库和静态库有什么本质的区别?为什么静态库不能被动态链接呢?</p>\n<p>其实，静态库从理论上来说也可以被动态链接到程序中去，只是静态库对于符号的描述中没有将符号描述为动态地址，操作系统的机制就是这样。</p>\n<p><strong>动态库也有两种实现方式</strong></p>\n<p>(1) 可重定位代码（relocatable code）：Windows DLL 以及不使用 -fPIC 的 Linux SO。 </p>\n<p>生成动态库时假定它被加载在地址 0 处。加载时它会被加载到一个地址（base），这时要进行一次重定位（relocation），把代码、数据段中所有的地址加上这个 base 的值。这样代码运行时就能使用正确的地址了。 </p>\n<p>(2) 位置无关代码（position independent code）：使用 -fPIC 的 Linux SO。 </p>\n<p>这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针（如 IA32 的 EIP 寄存器）的值，加上一个偏移得到全局变量&#x2F;函数的地址。 </p>\n<p>PIC vs. relocatable： </p>\n<p>(1) PIC 的缺点主要就是代码有可能长一些。例如 IA32，由于不能直接使用 [EIP+constant] 这样的寻址方式，甚至不能直接将 EIP 的值交给其他寄存器，要用到 GOT（global offset table）来定位全局变量和函数。这样导致代码的效率略低。 </p>\n<p>(2) PIC 的加载速度稍快，因为不需要做重定位。 </p>\n<p>(3) 多个进程引用同一个 PIC 动态库时，可以共用内存。这一个库在不同进程中的虚拟地址不同，但操作系统显然会把它们映射到同一块物理内存上。对于可重定位代码，则必须为每个库都在物理内存中复制一份副本，因为需要修改其中的地址。当然，主流现代操作系统都启用了分页内存机制，这使得重定位时可以使用 COW（copy on write）来节省内存（32 位 Windows 就是这样做的）；然而，页面的粒度还是比较大的（例如 IA32 上是 4KiB），至少对于代码段来说能节省的相当有限。 </p>\n<p><strong>也就是说，地址无关代码能够真正做到共享代码段，而重定向的方式是无法做到共享代码段的，因为需要重定位代码，使用写时复制的特性可以做到某些情况下共享代码段</strong></p>\n<p>在 Linux 下制作动态链接库，“标准” 的做法是编译成位置无关代码（Position Independent Code，PIC），然后链接成一个动态链接库。经常遇到的一个问题是 -fPIC 是不是必需，因为好像不加经常也能正常运行，只是创建 .so 的时候会有一个警告。 </p>\n<p>(1) 通常的建议是始终加上 -fPIC 生成位置无关代码； </p>\n<p>(2) AMD64 下，必须使用位置无关代码，否则连接失败： </p>\n<p>relocation R_X86_64_32S against &#96;a local symbol’ can not be used when making a shared object; recompile with -fPIC </p>\n<p>(3) IA32 下，连接成功，但有警告： </p>\n<p>warning: creating a DT_TEXTREL in object. </p>\n<p>如果加上-fPIC那么就使用地址无关代码来实现动态链接，否则使用重定向的方式来实现</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一个库可以通过两种方式链接到程序中</p>\n<p>1、静态链接:使用链接器ld在编译链接的过程中直接将所有符号链接到2进制可执行文件中，在链接的过程中完成符号的重定位。</p>\n<p>2、动态链接:使用动态连接器(linux下叫做ld.x.x.x.so),在程序运行时动态加载所需要的符号，然后进行重定位，或者使用dlopen等函数进行显式运行时链接，这里有两种方式，即在程序运行时动态链接，或者使用dlopen进行实时的动态链接</p>\n<p>那么、动态库和静态库有什么本质的区别?为什么静态库不能被动态链接呢?</p>\n<p>其实，静态库从理论上来说也可以被动态链接到程序中去，只是静态库对于符号的描述中没有将符号描述为动态地址，操作系统的机制就是这样。</p>\n<p><strong>动态库也有两种实现方式</strong></p>\n<p>(1) 可重定位代码（relocatable code）：Windows DLL 以及不使用 -fPIC 的 Linux SO。 </p>\n<p>生成动态库时假定它被加载在地址 0 处。加载时它会被加载到一个地址（base），这时要进行一次重定位（relocation），把代码、数据段中所有的地址加上这个 base 的值。这样代码运行时就能使用正确的地址了。 </p>\n<p>(2) 位置无关代码（position independent code）：使用 -fPIC 的 Linux SO。 </p>\n<p>这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针（如 IA32 的 EIP 寄存器）的值，加上一个偏移得到全局变量&#x2F;函数的地址。 </p>\n<p>PIC vs. relocatable： </p>\n<p>(1) PIC 的缺点主要就是代码有可能长一些。例如 IA32，由于不能直接使用 [EIP+constant] 这样的寻址方式，甚至不能直接将 EIP 的值交给其他寄存器，要用到 GOT（global offset table）来定位全局变量和函数。这样导致代码的效率略低。 </p>\n<p>(2) PIC 的加载速度稍快，因为不需要做重定位。 </p>\n<p>(3) 多个进程引用同一个 PIC 动态库时，可以共用内存。这一个库在不同进程中的虚拟地址不同，但操作系统显然会把它们映射到同一块物理内存上。对于可重定位代码，则必须为每个库都在物理内存中复制一份副本，因为需要修改其中的地址。当然，主流现代操作系统都启用了分页内存机制，这使得重定位时可以使用 COW（copy on write）来节省内存（32 位 Windows 就是这样做的）；然而，页面的粒度还是比较大的（例如 IA32 上是 4KiB），至少对于代码段来说能节省的相当有限。 </p>\n<p><strong>也就是说，地址无关代码能够真正做到共享代码段，而重定向的方式是无法做到共享代码段的，因为需要重定位代码，使用写时复制的特性可以做到某些情况下共享代码段</strong></p>\n<p>在 Linux 下制作动态链接库，“标准” 的做法是编译成位置无关代码（Position Independent Code，PIC），然后链接成一个动态链接库。经常遇到的一个问题是 -fPIC 是不是必需，因为好像不加经常也能正常运行，只是创建 .so 的时候会有一个警告。 </p>\n<p>(1) 通常的建议是始终加上 -fPIC 生成位置无关代码； </p>\n<p>(2) AMD64 下，必须使用位置无关代码，否则连接失败： </p>\n<p>relocation R_X86_64_32S against &#96;a local symbol’ can not be used when making a shared object; recompile with -fPIC </p>\n<p>(3) IA32 下，连接成功，但有警告： </p>\n<p>warning: creating a DT_TEXTREL in object. </p>\n<p>如果加上-fPIC那么就使用地址无关代码来实现动态链接，否则使用重定向的方式来实现</p>\n"},{"title":"可重入与线程安全","date":"2016-03-03T00:00:00.000Z","_content":"\n在多线程编程和信号处理过程中，经常会遇到可重入(reentrance)与线程安全(thread-safe)。\n\n很多人纠结于reentrance和thread-safe两个概念理解纠缠不清。我想就我对reentrance和thread-safe的理解作个总结\n\n \n\n----------\n\n\n# 一、可重入(reentrance) #\n可重入的函数列表请参考[这里](http://go.paowang.net/blog/hufey/archives/013961.html) \n\n那么究竟什么是可重入函数呢？\n\n \n\n我的理解：可重入函数，与多线程无关，即\n*可重入概念并不依赖于多线程*，可重入的提出时依据单一线程提出来的，当然，多线程可重入是他的扩展。一个函数被同一个线程调用2次以上，得到的结果具有可再现性(*多次调用函数，得到的结果是一样的*)。那么我们说这个函数是可重入的。\n\n\n可重入，并不一定要是多线程的。可重入只关注一个结果可再现性。在APUE中，可函数可重入的概念最先是在讲signal的handler的时候提出的。此时进程(线程)正在执行函数fun()，在函数fun()还未执行完的时候，突然进程接收到一个信号sig, 此时，需要暂停执行fun(),要转而执行sig信号的处理函数sig_handler()，那么，如果在sig_handler()中，也恰好调用了函数fun().信号的处理是以软终端的形式进行的，那么，当sig_handler()执行完返回之后，CPU会继续从fun()被打断的地方往下执行。这里讲的比较特殊，最好的情况是，进程中调用了fun()，函数，信号处理函数sig_handle()中也调用了fun()。如果fun()函数是可重入的，那么，多次调用fun()函数就具有可再现性。从而，两次调用fun()的结果是正确的预期结果。非可重入函数，则恰好相反。\n\n简而言之，可重入函数，描述的是函数被多次调用但是结果具有可再现性。 \n\n如果fun()，中，使用了static变量、返回全局变量、调用非可重入函数等等，带有全局性的操作，都将会导致2次以上调用fun()的结果的不可再现性（当然，有些时候使用了static、全局变量等等，不一定导致调用结果不可再现性）。只要使调用结果具有可再现性，那么该函数就是可重入的。\n\n为了保证函数是可重入的，需要做到一下几点：\n\n1，不在函数内部使用静态或者全局数据\n\n2，不返回静态或者全局数据，所有的数据都由函数调用者提供\n\n3，使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据\n\n4， 如果必须访问全局数据，使用互斥锁来保护\n\n5，不调用不可重入函数\n\n \n\n----------\n\n# 二，函数线程安全 #\n\n \n\n看看APUE上，描述的非线程安全函数\n\n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"data-table-1\" summary=\"POSIX.1 规范中的非线程安全函数\" width=\"100%\"><tbody><tr><th class=\"tb-row\" scope=\"row\">asctime</th><td>ecvt</td><td>gethostent</td><td>getutxline</td><td>putc_unlocked</td></tr><tr><th class=\"tb-row\" scope=\"row\">basename</th><td>encrypt</td><td>getlogin</td><td>gmtime</td><td>putchar_unlocked</td></tr><tr><th class=\"tb-row\" scope=\"row\">catgets</th><td>endgrent</td><td>getnetbyaddr</td><td>hcreate</td><td>putenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">crypt</th><td>endpwent</td><td>getnetbyname</td><td>hdestroy</td><td>pututxline</td></tr><tr><th class=\"tb-row\" scope=\"row\">ctime</th><td>endutxent</td><td>getopt</td><td>hsearch</td><td>rand</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_clearerr</th><td>fcvt</td><td>getprotobyname</td><td>inet_ntoa</td><td>readdir</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_close</th><td>ftw</td><td>getprotobynumber</td><td>L64a</td><td>setenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_delete</th><td>getcvt</td><td>getprotobynumber</td><td>lgamma</td><td>setgrent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_error</th><td>getc_unlocked</td><td>getprotoent</td><td>lgammaf</td><td>setkey</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_fetch</th><td>getchar_unlocked</td><td>getpwent</td><td>lgammal</td><td>setpwent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_firstkey</th><td>getdate</td><td>getpwnam</td><td>localeconv</td><td>setutxent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_nextkey</th><td>getenv</td><td>getpwuid</td><td>lrand48</td><td>strerror</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_open</th><td>getgrent</td><td>getservbyname</td><td>mrand48</td><td>strtok</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_store</th><td>getgrgid</td><td>getservbyport</td><td>nftw</td><td>ttyname</td></tr><tr><th class=\"tb-row\" scope=\"row\">dirname</th><td>getgrnam</td><td>getservent</td><td>nl_langinfo</td><td>unsetenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">dlerror</th><td>gethostbyaddr</td><td>getutxent</td><td>ptsname</td><td>wcstombs</td></tr><tr><th class=\"tb-row\" scope=\"row\">drand48</th><td>gethostbyname</td><td>getutxid</td><td>ptsname</td><td>ectomb</td></tr></tbody></table> \n\nIf a function can be safely called by multiple threads at the same time, we say that the function is thread-safe\n\n \n上面一段话是APUE中的解释，如果一个函数能够安全的同时被多个线程调用而得到正确的结果，那么，我们说这个函数是线程安全的。所谓安全，一切可能导致结果不正确的因素都是不安全的调用。\n\n\n线程安全，是针对多线程而言的。那么和可重入联系起来，我们可以断定，可重入函数必定是线程安全的，但是线程安全的，不一定是可重入的。不可重入函数，函数调用结果不具有可再现性，可以通过互斥锁等机制，使之能安全的同时被多个线程调用，那么，这个不可重入函数就是转换成了线程安全。\n\n \n\n线程安全，描述的是函数能同时被多个线程安全的调用，并不要求调用函数的结果具有可再现性。也就是说，多个线程同时调用该函数，允许出现互相影响的情况，这种情况的出现需要某些机制比如互斥锁来支持，使之安全。\n\n\n## 版权申明： ##\n转载文章请注明原文出处http://blog.csdn.net/feiyinzilgd/archive/2010/08/14/5811157.aspx\n","source":"_posts/可重入函数与线程安全.md","raw":"---\ntitle: \"可重入与线程安全\"\ndate: \"2016-03-03\"\ntags: [线程, 重入]\n---\n\n在多线程编程和信号处理过程中，经常会遇到可重入(reentrance)与线程安全(thread-safe)。\n\n很多人纠结于reentrance和thread-safe两个概念理解纠缠不清。我想就我对reentrance和thread-safe的理解作个总结\n\n \n\n----------\n\n\n# 一、可重入(reentrance) #\n可重入的函数列表请参考[这里](http://go.paowang.net/blog/hufey/archives/013961.html) \n\n那么究竟什么是可重入函数呢？\n\n \n\n我的理解：可重入函数，与多线程无关，即\n*可重入概念并不依赖于多线程*，可重入的提出时依据单一线程提出来的，当然，多线程可重入是他的扩展。一个函数被同一个线程调用2次以上，得到的结果具有可再现性(*多次调用函数，得到的结果是一样的*)。那么我们说这个函数是可重入的。\n\n\n可重入，并不一定要是多线程的。可重入只关注一个结果可再现性。在APUE中，可函数可重入的概念最先是在讲signal的handler的时候提出的。此时进程(线程)正在执行函数fun()，在函数fun()还未执行完的时候，突然进程接收到一个信号sig, 此时，需要暂停执行fun(),要转而执行sig信号的处理函数sig_handler()，那么，如果在sig_handler()中，也恰好调用了函数fun().信号的处理是以软终端的形式进行的，那么，当sig_handler()执行完返回之后，CPU会继续从fun()被打断的地方往下执行。这里讲的比较特殊，最好的情况是，进程中调用了fun()，函数，信号处理函数sig_handle()中也调用了fun()。如果fun()函数是可重入的，那么，多次调用fun()函数就具有可再现性。从而，两次调用fun()的结果是正确的预期结果。非可重入函数，则恰好相反。\n\n简而言之，可重入函数，描述的是函数被多次调用但是结果具有可再现性。 \n\n如果fun()，中，使用了static变量、返回全局变量、调用非可重入函数等等，带有全局性的操作，都将会导致2次以上调用fun()的结果的不可再现性（当然，有些时候使用了static、全局变量等等，不一定导致调用结果不可再现性）。只要使调用结果具有可再现性，那么该函数就是可重入的。\n\n为了保证函数是可重入的，需要做到一下几点：\n\n1，不在函数内部使用静态或者全局数据\n\n2，不返回静态或者全局数据，所有的数据都由函数调用者提供\n\n3，使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据\n\n4， 如果必须访问全局数据，使用互斥锁来保护\n\n5，不调用不可重入函数\n\n \n\n----------\n\n# 二，函数线程安全 #\n\n \n\n看看APUE上，描述的非线程安全函数\n\n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"data-table-1\" summary=\"POSIX.1 规范中的非线程安全函数\" width=\"100%\"><tbody><tr><th class=\"tb-row\" scope=\"row\">asctime</th><td>ecvt</td><td>gethostent</td><td>getutxline</td><td>putc_unlocked</td></tr><tr><th class=\"tb-row\" scope=\"row\">basename</th><td>encrypt</td><td>getlogin</td><td>gmtime</td><td>putchar_unlocked</td></tr><tr><th class=\"tb-row\" scope=\"row\">catgets</th><td>endgrent</td><td>getnetbyaddr</td><td>hcreate</td><td>putenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">crypt</th><td>endpwent</td><td>getnetbyname</td><td>hdestroy</td><td>pututxline</td></tr><tr><th class=\"tb-row\" scope=\"row\">ctime</th><td>endutxent</td><td>getopt</td><td>hsearch</td><td>rand</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_clearerr</th><td>fcvt</td><td>getprotobyname</td><td>inet_ntoa</td><td>readdir</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_close</th><td>ftw</td><td>getprotobynumber</td><td>L64a</td><td>setenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_delete</th><td>getcvt</td><td>getprotobynumber</td><td>lgamma</td><td>setgrent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_error</th><td>getc_unlocked</td><td>getprotoent</td><td>lgammaf</td><td>setkey</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_fetch</th><td>getchar_unlocked</td><td>getpwent</td><td>lgammal</td><td>setpwent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_firstkey</th><td>getdate</td><td>getpwnam</td><td>localeconv</td><td>setutxent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_nextkey</th><td>getenv</td><td>getpwuid</td><td>lrand48</td><td>strerror</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_open</th><td>getgrent</td><td>getservbyname</td><td>mrand48</td><td>strtok</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_store</th><td>getgrgid</td><td>getservbyport</td><td>nftw</td><td>ttyname</td></tr><tr><th class=\"tb-row\" scope=\"row\">dirname</th><td>getgrnam</td><td>getservent</td><td>nl_langinfo</td><td>unsetenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">dlerror</th><td>gethostbyaddr</td><td>getutxent</td><td>ptsname</td><td>wcstombs</td></tr><tr><th class=\"tb-row\" scope=\"row\">drand48</th><td>gethostbyname</td><td>getutxid</td><td>ptsname</td><td>ectomb</td></tr></tbody></table> \n\nIf a function can be safely called by multiple threads at the same time, we say that the function is thread-safe\n\n \n上面一段话是APUE中的解释，如果一个函数能够安全的同时被多个线程调用而得到正确的结果，那么，我们说这个函数是线程安全的。所谓安全，一切可能导致结果不正确的因素都是不安全的调用。\n\n\n线程安全，是针对多线程而言的。那么和可重入联系起来，我们可以断定，可重入函数必定是线程安全的，但是线程安全的，不一定是可重入的。不可重入函数，函数调用结果不具有可再现性，可以通过互斥锁等机制，使之能安全的同时被多个线程调用，那么，这个不可重入函数就是转换成了线程安全。\n\n \n\n线程安全，描述的是函数能同时被多个线程安全的调用，并不要求调用函数的结果具有可再现性。也就是说，多个线程同时调用该函数，允许出现互相影响的情况，这种情况的出现需要某些机制比如互斥锁来支持，使之安全。\n\n\n## 版权申明： ##\n转载文章请注明原文出处http://blog.csdn.net/feiyinzilgd/archive/2010/08/14/5811157.aspx\n","slug":"可重入函数与线程安全","published":1,"updated":"2023-04-15T08:57:13.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clghs86k70008sgvi0bu6gzr0","content":"<p>在多线程编程和信号处理过程中，经常会遇到可重入(reentrance)与线程安全(thread-safe)。</p>\n<p>很多人纠结于reentrance和thread-safe两个概念理解纠缠不清。我想就我对reentrance和thread-safe的理解作个总结</p>\n<hr>\n<h1 id=\"一、可重入-reentrance\"><a href=\"#一、可重入-reentrance\" class=\"headerlink\" title=\"一、可重入(reentrance)\"></a>一、可重入(reentrance)</h1><p>可重入的函数列表请参考<a href=\"http://go.paowang.net/blog/hufey/archives/013961.html\">这里</a> </p>\n<p>那么究竟什么是可重入函数呢？</p>\n<p>我的理解：可重入函数，与多线程无关，即<br><em>可重入概念并不依赖于多线程</em>，可重入的提出时依据单一线程提出来的，当然，多线程可重入是他的扩展。一个函数被同一个线程调用2次以上，得到的结果具有可再现性(<em>多次调用函数，得到的结果是一样的</em>)。那么我们说这个函数是可重入的。</p>\n<p>可重入，并不一定要是多线程的。可重入只关注一个结果可再现性。在APUE中，可函数可重入的概念最先是在讲signal的handler的时候提出的。此时进程(线程)正在执行函数fun()，在函数fun()还未执行完的时候，突然进程接收到一个信号sig, 此时，需要暂停执行fun(),要转而执行sig信号的处理函数sig_handler()，那么，如果在sig_handler()中，也恰好调用了函数fun().信号的处理是以软终端的形式进行的，那么，当sig_handler()执行完返回之后，CPU会继续从fun()被打断的地方往下执行。这里讲的比较特殊，最好的情况是，进程中调用了fun()，函数，信号处理函数sig_handle()中也调用了fun()。如果fun()函数是可重入的，那么，多次调用fun()函数就具有可再现性。从而，两次调用fun()的结果是正确的预期结果。非可重入函数，则恰好相反。</p>\n<p>简而言之，可重入函数，描述的是函数被多次调用但是结果具有可再现性。 </p>\n<p>如果fun()，中，使用了static变量、返回全局变量、调用非可重入函数等等，带有全局性的操作，都将会导致2次以上调用fun()的结果的不可再现性（当然，有些时候使用了static、全局变量等等，不一定导致调用结果不可再现性）。只要使调用结果具有可再现性，那么该函数就是可重入的。</p>\n<p>为了保证函数是可重入的，需要做到一下几点：</p>\n<p>1，不在函数内部使用静态或者全局数据</p>\n<p>2，不返回静态或者全局数据，所有的数据都由函数调用者提供</p>\n<p>3，使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据</p>\n<p>4， 如果必须访问全局数据，使用互斥锁来保护</p>\n<p>5，不调用不可重入函数</p>\n<hr>\n<h1 id=\"二，函数线程安全\"><a href=\"#二，函数线程安全\" class=\"headerlink\" title=\"二，函数线程安全\"></a>二，函数线程安全</h1><p>看看APUE上，描述的非线程安全函数</p>\n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"data-table-1\" summary=\"POSIX.1 规范中的非线程安全函数\" width=\"100%\"><tbody><tr><th class=\"tb-row\" scope=\"row\">asctime</th><td>ecvt</td><td>gethostent</td><td>getutxline</td><td>putc_unlocked</td></tr><tr><th class=\"tb-row\" scope=\"row\">basename</th><td>encrypt</td><td>getlogin</td><td>gmtime</td><td>putchar_unlocked</td></tr><tr><th class=\"tb-row\" scope=\"row\">catgets</th><td>endgrent</td><td>getnetbyaddr</td><td>hcreate</td><td>putenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">crypt</th><td>endpwent</td><td>getnetbyname</td><td>hdestroy</td><td>pututxline</td></tr><tr><th class=\"tb-row\" scope=\"row\">ctime</th><td>endutxent</td><td>getopt</td><td>hsearch</td><td>rand</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_clearerr</th><td>fcvt</td><td>getprotobyname</td><td>inet_ntoa</td><td>readdir</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_close</th><td>ftw</td><td>getprotobynumber</td><td>L64a</td><td>setenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_delete</th><td>getcvt</td><td>getprotobynumber</td><td>lgamma</td><td>setgrent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_error</th><td>getc_unlocked</td><td>getprotoent</td><td>lgammaf</td><td>setkey</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_fetch</th><td>getchar_unlocked</td><td>getpwent</td><td>lgammal</td><td>setpwent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_firstkey</th><td>getdate</td><td>getpwnam</td><td>localeconv</td><td>setutxent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_nextkey</th><td>getenv</td><td>getpwuid</td><td>lrand48</td><td>strerror</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_open</th><td>getgrent</td><td>getservbyname</td><td>mrand48</td><td>strtok</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_store</th><td>getgrgid</td><td>getservbyport</td><td>nftw</td><td>ttyname</td></tr><tr><th class=\"tb-row\" scope=\"row\">dirname</th><td>getgrnam</td><td>getservent</td><td>nl_langinfo</td><td>unsetenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">dlerror</th><td>gethostbyaddr</td><td>getutxent</td><td>ptsname</td><td>wcstombs</td></tr><tr><th class=\"tb-row\" scope=\"row\">drand48</th><td>gethostbyname</td><td>getutxid</td><td>ptsname</td><td>ectomb</td></tr></tbody></table> \n\n<p>If a function can be safely called by multiple threads at the same time, we say that the function is thread-safe</p>\n<p>上面一段话是APUE中的解释，如果一个函数能够安全的同时被多个线程调用而得到正确的结果，那么，我们说这个函数是线程安全的。所谓安全，一切可能导致结果不正确的因素都是不安全的调用。</p>\n<p>线程安全，是针对多线程而言的。那么和可重入联系起来，我们可以断定，可重入函数必定是线程安全的，但是线程安全的，不一定是可重入的。不可重入函数，函数调用结果不具有可再现性，可以通过互斥锁等机制，使之能安全的同时被多个线程调用，那么，这个不可重入函数就是转换成了线程安全。</p>\n<p>线程安全，描述的是函数能同时被多个线程安全的调用，并不要求调用函数的结果具有可再现性。也就是说，多个线程同时调用该函数，允许出现互相影响的情况，这种情况的出现需要某些机制比如互斥锁来支持，使之安全。</p>\n<h2 id=\"版权申明：\"><a href=\"#版权申明：\" class=\"headerlink\" title=\"版权申明：\"></a>版权申明：</h2><p>转载文章请注明原文出处<a href=\"http://blog.csdn.net/feiyinzilgd/archive/2010/08/14/5811157.aspx\">http://blog.csdn.net/feiyinzilgd/archive/2010/08/14/5811157.aspx</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在多线程编程和信号处理过程中，经常会遇到可重入(reentrance)与线程安全(thread-safe)。</p>\n<p>很多人纠结于reentrance和thread-safe两个概念理解纠缠不清。我想就我对reentrance和thread-safe的理解作个总结</p>\n<hr>\n<h1 id=\"一、可重入-reentrance\"><a href=\"#一、可重入-reentrance\" class=\"headerlink\" title=\"一、可重入(reentrance)\"></a>一、可重入(reentrance)</h1><p>可重入的函数列表请参考<a href=\"http://go.paowang.net/blog/hufey/archives/013961.html\">这里</a> </p>\n<p>那么究竟什么是可重入函数呢？</p>\n<p>我的理解：可重入函数，与多线程无关，即<br><em>可重入概念并不依赖于多线程</em>，可重入的提出时依据单一线程提出来的，当然，多线程可重入是他的扩展。一个函数被同一个线程调用2次以上，得到的结果具有可再现性(<em>多次调用函数，得到的结果是一样的</em>)。那么我们说这个函数是可重入的。</p>\n<p>可重入，并不一定要是多线程的。可重入只关注一个结果可再现性。在APUE中，可函数可重入的概念最先是在讲signal的handler的时候提出的。此时进程(线程)正在执行函数fun()，在函数fun()还未执行完的时候，突然进程接收到一个信号sig, 此时，需要暂停执行fun(),要转而执行sig信号的处理函数sig_handler()，那么，如果在sig_handler()中，也恰好调用了函数fun().信号的处理是以软终端的形式进行的，那么，当sig_handler()执行完返回之后，CPU会继续从fun()被打断的地方往下执行。这里讲的比较特殊，最好的情况是，进程中调用了fun()，函数，信号处理函数sig_handle()中也调用了fun()。如果fun()函数是可重入的，那么，多次调用fun()函数就具有可再现性。从而，两次调用fun()的结果是正确的预期结果。非可重入函数，则恰好相反。</p>\n<p>简而言之，可重入函数，描述的是函数被多次调用但是结果具有可再现性。 </p>\n<p>如果fun()，中，使用了static变量、返回全局变量、调用非可重入函数等等，带有全局性的操作，都将会导致2次以上调用fun()的结果的不可再现性（当然，有些时候使用了static、全局变量等等，不一定导致调用结果不可再现性）。只要使调用结果具有可再现性，那么该函数就是可重入的。</p>\n<p>为了保证函数是可重入的，需要做到一下几点：</p>\n<p>1，不在函数内部使用静态或者全局数据</p>\n<p>2，不返回静态或者全局数据，所有的数据都由函数调用者提供</p>\n<p>3，使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据</p>\n<p>4， 如果必须访问全局数据，使用互斥锁来保护</p>\n<p>5，不调用不可重入函数</p>\n<hr>\n<h1 id=\"二，函数线程安全\"><a href=\"#二，函数线程安全\" class=\"headerlink\" title=\"二，函数线程安全\"></a>二，函数线程安全</h1><p>看看APUE上，描述的非线程安全函数</p>\n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"data-table-1\" summary=\"POSIX.1 规范中的非线程安全函数\" width=\"100%\"><tbody><tr><th class=\"tb-row\" scope=\"row\">asctime</th><td>ecvt</td><td>gethostent</td><td>getutxline</td><td>putc_unlocked</td></tr><tr><th class=\"tb-row\" scope=\"row\">basename</th><td>encrypt</td><td>getlogin</td><td>gmtime</td><td>putchar_unlocked</td></tr><tr><th class=\"tb-row\" scope=\"row\">catgets</th><td>endgrent</td><td>getnetbyaddr</td><td>hcreate</td><td>putenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">crypt</th><td>endpwent</td><td>getnetbyname</td><td>hdestroy</td><td>pututxline</td></tr><tr><th class=\"tb-row\" scope=\"row\">ctime</th><td>endutxent</td><td>getopt</td><td>hsearch</td><td>rand</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_clearerr</th><td>fcvt</td><td>getprotobyname</td><td>inet_ntoa</td><td>readdir</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_close</th><td>ftw</td><td>getprotobynumber</td><td>L64a</td><td>setenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_delete</th><td>getcvt</td><td>getprotobynumber</td><td>lgamma</td><td>setgrent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_error</th><td>getc_unlocked</td><td>getprotoent</td><td>lgammaf</td><td>setkey</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_fetch</th><td>getchar_unlocked</td><td>getpwent</td><td>lgammal</td><td>setpwent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_firstkey</th><td>getdate</td><td>getpwnam</td><td>localeconv</td><td>setutxent</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_nextkey</th><td>getenv</td><td>getpwuid</td><td>lrand48</td><td>strerror</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_open</th><td>getgrent</td><td>getservbyname</td><td>mrand48</td><td>strtok</td></tr><tr><th class=\"tb-row\" scope=\"row\">dbm_store</th><td>getgrgid</td><td>getservbyport</td><td>nftw</td><td>ttyname</td></tr><tr><th class=\"tb-row\" scope=\"row\">dirname</th><td>getgrnam</td><td>getservent</td><td>nl_langinfo</td><td>unsetenv</td></tr><tr><th class=\"tb-row\" scope=\"row\">dlerror</th><td>gethostbyaddr</td><td>getutxent</td><td>ptsname</td><td>wcstombs</td></tr><tr><th class=\"tb-row\" scope=\"row\">drand48</th><td>gethostbyname</td><td>getutxid</td><td>ptsname</td><td>ectomb</td></tr></tbody></table> \n\n<p>If a function can be safely called by multiple threads at the same time, we say that the function is thread-safe</p>\n<p>上面一段话是APUE中的解释，如果一个函数能够安全的同时被多个线程调用而得到正确的结果，那么，我们说这个函数是线程安全的。所谓安全，一切可能导致结果不正确的因素都是不安全的调用。</p>\n<p>线程安全，是针对多线程而言的。那么和可重入联系起来，我们可以断定，可重入函数必定是线程安全的，但是线程安全的，不一定是可重入的。不可重入函数，函数调用结果不具有可再现性，可以通过互斥锁等机制，使之能安全的同时被多个线程调用，那么，这个不可重入函数就是转换成了线程安全。</p>\n<p>线程安全，描述的是函数能同时被多个线程安全的调用，并不要求调用函数的结果具有可再现性。也就是说，多个线程同时调用该函数，允许出现互相影响的情况，这种情况的出现需要某些机制比如互斥锁来支持，使之安全。</p>\n<h2 id=\"版权申明：\"><a href=\"#版权申明：\" class=\"headerlink\" title=\"版权申明：\"></a>版权申明：</h2><p>转载文章请注明原文出处<a href=\"http://blog.csdn.net/feiyinzilgd/archive/2010/08/14/5811157.aspx\">http://blog.csdn.net/feiyinzilgd/archive/2010/08/14/5811157.aspx</a></p>\n"},{"title":"快速上手Docker","_content":"\n![png1](../../image/docker.png)\n\n## Docker是什么？\n\nDocker主要是为了解决软件的运行环境问题，当然，主要是Linux软件，举一个简单的例子\n小明开发了一个网站，这个网站用到的技术包括Nginx，Python，MySQL，Redis，现在小明需要把这个网站部署上线，那么他至少要在一个服务器上做下面几件事\n1、在服务器上安装Nginx，Python，MySQL，Redis软件\n2、对机器和软件进行相关的配置设置，例如MySQL的端口号，Redis的端口号等\n3、把自己开发的网站代码打包，并且上传到服务器上，然后启动相关服务\n以上步骤是非常简化的版本，实际上如果真的要手动部署，可能会遇到更多问题\nDocker就是解决上面这些问题的，有了Docker，小明在任何一台服务器上部署自己的软件，只需要简单的一个命令\n\n``` shell\n$ docker run my-web-app\n```\n\nDocker会自动下载相关镜像，并且自动创建一个完全隔离的环境，然后运行相关的软件，这得益于LInux的底层隔离技术，包括Linux 命名空间、控制组和 UnionFS ，注意：Docker与虚拟机不同，虽然二者有点类似，但是Docker的隔离更轻量级，Docker并不是真正的虚拟机，Docker在底层是共享操作系统内核的，而虚拟机则不共享操作系统内核\n\n\n## 安装Docker\n\n\nLinux:\n\n``` shell\n$ curl -fsSL https://get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh\n```\n\n注意：如果安装了旧版本的Docker，需要使用对应的包管理工具卸载\n\nWindows 10 或 MacOS(不支持黑苹果)：\n[安装Docker Desktop](https://docs.docker.com/engine/install/)\n\n当然，如果是带UI的Linux发行版也可以安装Linux版本的Docker Desktop\n安装完成后在终端运行：\n\n``` shell\n$ docker version\n```\n如果看到版本信息则代表安装成功\n\n## Docker命令：\n\nDocker CLI的全量命令请参考:[这里](https://docs.docker.com/engine/reference/commandline/docker/)\n\n\n### 使用docker运行nginx\n\ndocker run可以直接运行一个容器，当本地不存在时，docker会从远端仓库拉取，默认的远端仓库是docker官方的docker hub，安装了Docker以后，基本上就不需要手动在服务器上安装任何软件了，假如你想运行一个nginx，那么你可以直接用下面的命令：\n\n``` shell\n$ docker run nginx\n```\n\n输出：\n``` shell\nUnable to find image 'nginx:latest' locally\nlatest: Pulling from library/nginx\na2abf6c4d29d: Pull complete\na9edb18cadd1: Pull complete\n589b7251471a: Pull complete\n186b1aaa4aa6: Pull complete\nb4df32aa5a72: Pull complete\na0bcbecc962e: Pull complete\nDigest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31\nStatus: Downloaded newer image for nginx:latest\n/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration\n/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh\n10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf\n10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh\n/docker-entrypoint.sh: Configuration complete; ready for start up\n2022/06/26 02:59:53 [notice] 1#1: using the \"epoll\" event method\n2022/06/26 02:59:53 [notice] 1#1: nginx/1.21.5\n2022/06/26 02:59:53 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)\n2022/06/26 02:59:53 [notice] 1#1: OS: Linux 4.19.130-boot2docker\n2022/06/26 02:59:53 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576\n2022/06/26 02:59:53 [notice] 1#1: start worker processes\n2022/06/26 02:59:53 [notice] 1#1: start worker process 30\n```\n\n这样，nginx就直接运行起来了，但是默认没有在后台运行，当按下Ctrl+C软件就退出了，可以使用-d参数，让docker在后台运行该容器\n\n``` shell\n$ docker run -d nginx\n182214dcd10b23bba2559116d13171745550a5a52c745aa699a895edeb55b7d0\n```\n\ndocker 输出一串ID，nginx容器就在后台运行了，这个ID可以唯一标识一个容器，当需要输入这个ID时，大部分情况下并不需要输入完整的ID，输入前面几个字符就可以了\n使用docker ps 查看正在运行的容器\n``` shell\n$ docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES\n182214dcd10b   nginx     \"/docker-entrypoint.…\"   14 minutes ago   Up 14 minutes   80/tcp    cool_williams\n```\n\n可以看到正在运行的容器ID，使用的镜像，创建的时间还有端口号，名字等信息。\n使用 stop 命令停止容器\n``` shell\n$ docker stop 182214dcd10b\n$ 182214dcd10b\n```\n\n此时 docker ps无法查看该停止的容器\n``` shell\n$ docker ps\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n```\n\n使用 docker ps -a 可以查看所有状态的容器\n``` shell\n$ docker ps -a\nCONTAINER ID   IMAGE         COMMAND                  CREATED             STATUS                          PORTS     NAMES\n182214dcd10b   nginx         \"/docker-entrypoint.…\"   20 minutes ago      Exited (0) About a minute ago             cool_williams\n325b084cc16a   nginx         \"/docker-entrypoint.…\"   About an hour ago   Exited (0) 20 minutes ago                 priceless_cori\nc7e018e16d23   hello-world   \"/hello\"                 2 hours ago         Exited (0) 2 hours ago                    frosty_euclid\n```\n\n注意，此时无法通过外部的浏览器访问这个nginx服务器，因为docker内部的端口并没有暴露出来，可以运行下面的命令进行端口映射\n\n``` shell\n$ docker run -d -p 80:80 nginx\n```\n\n-p参数把docker内部的80端口映射到本机的80端口，打开浏览器，输入localhost就可以看到Nginx的欢迎页面了。\n-v参数可以挂载本地文件目录，一般在运行数据库容器时，需要将数据持久化，否则在容器退出后所有的数据将丢失；例如：\n\n``` shell\n$ docker run -d -p 80:80 -v /data/nginx:/data nginx\n```\n\n以上命令将本机的/data/nginx目录挂到到容器中的/data目录，如果容器中对/data目录的任何修改都将直接映射到外部磁盘上\ndocker exec命令可以在指定的容器内部执行命令，分为交互式和非交互式两种方式\n非交互式：\n``` shell\n$ docker exec 182214dcd10b ls -al /var\n```\n\nexec后面是docker id，然后紧跟要在容器中运行的命令\n交互式\n``` shell\n$ docker exec -it 182214dcd10b bash\n```\n\n-i选项代表使用交互方式，-t代表打开一个终端，bash是本次要运行的命令，一个shell程序\n这样就相当于打开了一个交互式终端进入了容器内部，所做的操作都只在容器内部生效，如同进入了一个虚拟机，使用exit命令来退出容器。\n\n## 使用DockerFile创建自己的容器\n\nDocker使用一种称为Dockerfile的文件来描述容器的组成以及相关配置，Dockerfile是docker的特有文件，必须满足相关格式\n假如要创建自己的web程序，需要将所有依赖都打包到一个镜像中，以某个操作系统为底座来构筑自己的镜像\n作为样例，我们使用python的flask框架来编写一个最简单的网页程序，并打包成一个镜像；关于flask可以参考如下[链接](https://flask.palletsprojects.com/en/2.1.x/)\n\n1、新建一个文件夹\n``` shell\nmkdir flask\n```\n\n2、打开一个py文件app.py，写入如下内容：\n``` python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello_world():\n    return \"<p>Hello, World!</p>\"\n\nif __name__ == \"__main__\":\n     app.run(host=\"0.0.0.0\", debug=True)\n```\n\n3、新建一个文件命名为dockerfile，写入如下内容：\n``` dockerfile\n#这是一个注释\nFROM ubuntu\n\nRUN apt-get update\nRUN apt-get install -y nginx\nRUN apt-get install -y python3\nRUN apt-get install -y python3-flask\nCOPY app.py /var/hello.py\nENV FLASK_APP=hello\nCMD cd /var && flask run\n```\n\ndockerfile其实只有一种格式，就是\n``` dockerfile\n# 注释\nINSTRUCTION arguments \n```\n\n一个命令然后紧跟参数\ndockerfile必须以FROM开始，代表在某个基础镜像上做接下来的操作，一般情况下以某个操作系统或某个现成的软件镜像开始；\n其他常用命令包括：\nRUN命令可以在镜像内部运行某个命令，本例中是使用apt-get命令来安装必要的软件\nCOPY命令可以将本地文件拷贝到容器内部，注意只能拷贝当前目录下的内容，因此COPY ../xxx xxx这种形式是无法成功的\nENV命令则可以简单的对容器注入环境变量\nCMD命令用于指定当容器运行时需要执行的默认命令，CMD命令可以被docker run命令覆盖，如果不希望被覆盖，可以考虑使用ENTRYPOINT\n全部的dockerfile手册请参考[官方文档](https://docs.docker.com/engine/reference/builder/#usage)\n\n之后就可以通过docker buid命令来构建镜像了\n4、运行：\n``` shell\n$ docker build -t flask:latest .\n```\n得到如下输出：\n``` shell\n[+] Building 0.2s (11/11) FINISHED\n => [internal] load build definition from Dockerfile                                                                                   0.0s\n => => transferring dockerfile: 248B                                                                                                   0.0s\n => [internal] load .dockerignore                                                                                                      0.0s\n => => transferring context: 2B                                                                                                        0.0s\n => [internal] load metadata for docker.io/library/ubuntu:latest                                                                       0.0s\n => [internal] load build context                                                                                                      0.0s\n => => transferring context: 27B                                                                                                       0.0s\n => [1/6] FROM docker.io/library/ubuntu                                                                                                0.0s\n => CACHED [2/6] RUN apt-get update                                                                                                    0.0s\n => CACHED [3/6] RUN apt-get install -y nginx                                                                                          0.0s\n => CACHED [4/6] RUN apt-get install -y python3                                                                                        0.0s\n => [6/6] COPY app.py /var/hello.py                                                                                                    0.0s\n => exporting to image                                                                                                                 0.0s\n => => writing image sha256:8ee4b660822edecb1bbe35f0421d57cfa94fe51533d16737e9ca0c84292fedf8                                           0.0s\n => => naming to docker.io/library/flask:latest                                                                                        0.0s\n ```\n-t 参数用于指明镜像的名称和tag，后面紧跟一个目录，docker会自动查找该目录下的dockerfile并根据该文件来进行镜像构建\n构建完成后可以使用docker image ls命令来查看当前机器上所有的镜像列表\n```  shell\n$ docker image ls\nREPOSITORY   TAG       IMAGE ID       CREATED         SIZE\nflask        latest    8ee4b660822e   5 seconds ago   213MB\n<none>       <none>    8b35a6e3e43d   7 minutes ago   213MB\nnginx        latest    605c77e624dd   6 months ago    141MB\nubuntu       latest    ba6acccedd29   8 months ago    72.8MB\n```\ndocker image命令是用来管理镜像的，使用方法可以通过:\n\n``` shell\n$ docker image --help\nUsage:  docker image COMMAND\n\nManage images\n\nCommands:\n  build       Build an image from a Dockerfile\n  history     Show the history of an image\n  import      Import the contents from a tarball to create a filesystem image\n  inspect     Display detailed information on one or more images\n  load        Load an image from a tar archive or STDIN\n  ls          List images\n  prune       Remove unused images\n  pull        Pull an image or a repository from a registry\n  push        Push an image or a repository to a registry\n  rm          Remove one or more images\n  save        Save one or more images to a tar archive (streamed to STDOUT by default)\n  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE\n```\n\n对于任意的docker命令都可以通过 docker COMMAND --help来查看使用方法。\n运行一下制作的镜像\n``` shell\n$ docker run flask\n * Serving Flask app \"hello\"\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n```\n至此，镜像已经成功制作并运行\n\n## Docker Registry 镜像仓库\n\ngit有github，docker也有docker hub，和git类似，docker需要一个存储所有镜像的地方，这样你可以和别人共享你制作的镜像，也可以使用别人制作的镜像，Docker官方提供的默认仓库是Docker hub，如果要修改默认的仓库可以运行：\n\n``` shell\nsudo vim /etc/docker/daemon.json\n```\n\n写入：\n``` json\n{\n  \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]\n}\n```\n列表中可以使用任何提供docker仓库服务的地址，上述例子中使用的是中科大的镜像仓库。\n接着，需要使配置生效：\n\n``` shell\nsudo systemctl daemon-reload \nsudo service docker restart \n```\n\n当然也可以使用本地仓库，使用本地仓库需要使用docker-registry，docker通过一个镜像提供了该服务，运行：\n\n``` shell\n$ docker run -d -p 5000:5000 --restart=always --name registry registry\n```\n默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /data/registry 目录。\n\n``` shell\n$ docker run -d  -p 5000:5000  -v /data/registry:/var/lib/registry registry\n```\n这样就运行了一个本地仓库并且镜像持久化的存储在/data/registry目录下。\n先尝试将本地的镜像推到仓库中：\n\n``` shell\n$ docker push 127.0.0.1:5000/ubuntu:latest\nThe push refers to repository [127.0.0.1:5000/ubuntu]\n373a30c24545: Pushed\na9148f5200b0: Pushed\ncdd3de0940ab: Pushed\nfc56279bbb33: Pushed\nb38367233d37: Pushed\n2aebd096e0e2: Pushed\nlatest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568\n```\n\n用 curl 查看仓库中的镜像。\n``` shell\n$ curl 127.0.0.1:5000/v2/_catalog\n{\"repositories\":[\"ubuntu\"]}\n```\n\n可以看到 {\"repositories\":[\"ubuntu\"]}，表明镜像已经被成功上传了。\n\n## Docker compose\n我们往往需要多个容器配合来完成某个上层应用，例如网站程序经常需要搭配一个数据库使用，这种情况可以把网站后台程序和数据库分别放到两个容器中运行，Docker compose工具提供一种简化的方式来组织多个容器，并且能够用一个命令快速的部署多个容器；\nDocker compose使用YAML文件来描述容器以及容器之间的关系，使用Docker compose一般分为3步\n- 定义每个容器的Dockerfile\n- 定义一个称为docker-compose.yaml的文件，用来描述多个容器之间的关系\n- 使用docker compose up命令一键部署应用程序\n我们仍然以上个例子中的flask程序为基础，并新增一个计数功能，为此我们需要改写我们的web程序，如下:\n\n``` python\nfrom flask import Flask\nfrom redis import Redis\n\napp = Flask(__name__)\nredis = Redis(host='redis', port=6379)\n\n@app.route('/')\ndef hello():\n     count = redis.incr('hits')\n     return '<p>Hello World! {} times。</p>'.format(count)\n\nif __name__ == \"__main__\":\n     app.run(host=\"0.0.0.0\", debug=True)\n```\n\n经过修改后，我们的程序会连接一个Redis数据库，并且每次被访问到，都会将计数加一，并展示到页面，为了连接Redis我们必须运行一个Redis的容器，好在该容器官方都制作好了，因此直接运行\n``` shell\n$ docker run -d redis\n```\n就可以直接运行一个Redis数据库，但是此时web程序并没有连接到这个Redis容器，我们需要定义两个容器的关系\n编写一个简单的docker-compose.yaml文件\n\n``` yaml\nservices:\n     web:\n         build: .\n         ports:\n             - \"5000:5000\"\n     redis:\n         image: \"redis:alpine\"\n```\n\ndocker-compose文件必须有一个services字段，每一个service可以理解为一个由多个容器组成的一个上层应用上述例子中的service由两个容器组成，名字分别是web、redis，其中web容器需要使用docker build命令来构筑镜像，使用的目录为当前目录，并且需要把端口5000映射到主机的5000端口\nredis容器责直接从系统配置的docker registry中尝试直接获取镜像\n运行\n\n``` shell\n$ docker compose up\n[+] Running 2/2\n - Container nginxpython-redis-1  Started                                                                0.3s\n - Container nginxpython-web-1    Started                                                                0.3s\n```\n\n此时两个容器就一并开始构建和启动起来了\n这里需要解释一个问题：为什么使用docker compose，flask程序就可以直接连接到一个名字为'redis'的主机上，他又是怎么找到这个主机的呢? 这与docker network的机制有关。\n\n## Docker network\n第一次安装完Docker，直接运行\n\n``` shell\n$ docker network ls\n```\n\n能够直接看到docker建立的默认网络，总共有3个\n\n``` shell\nNETWORK ID     NAME      DRIVER    SCOPE\n479bda8f37b9   bridge    bridge    local\n273213114bfe   host      host      local\ncce99c0034c4   none      null      local\n```\n\nbridge：docker 默认使用的是bridge，原理上是一个软件实现的二层交换机，如果不使用任何参数运行容器，那么默认会连接到bridge上，也就是说，默认一个机器上的容器都是可以互联互通的，但是这种情况下也只能通过IP来互联互通，无法通过hostname进行交互\nhost：移除容器和 Docker 宿主机之间的网络隔离，并直接使用主机的网络。host 模式仅适用于 Docker 17.06+\nnone：对于此容器，禁用所有联网。通常与自定义网络驱动程序一起使用。none 模式不适用于集群服务\n在Docker compose章节的例子中，flask程序是直接连接的一个名为'redis'的host，而容器本身并不知道redis这个host对应的ip地址是什么，所以无法连接\n如果要解决这个问题，我们可以手动修改flask程序的host文件，配置上redis容器的地址以及host，这样就可以互通了\n还有另外一种方法就是使用docker compose命令，如同上个章节那样，这种情况下，docker会默认建立一个自定义网络，而不是使用默认的bridge网络，此外，如果使用自定义网络，docker还会默认提供一个DNS服务器，用于一个services下的各个容器之间的域名解析，在运行完docker compose up后，可以查看docker network ls，会发现docker建立了一个网络，名称为nginxpython_default   \n```\n$ docker network ls\nNETWORK ID     NAME                  DRIVER    SCOPE\nadd5f8daed77   bridge                bridge    local\n3c065d8a1d64   host                  host      local\n41afd011cef9   nginxpython_default   bridge    local\nc31bc25f91ae   none                  null      local\n```\n此时，该docker compose定义的两个容器就能够通过镜像名称作为主机名称进行互联，且网络与其他容器是隔离的\ndocker 网络相关材料请参考[官方文档](https://docs.docker.com/network/)","source":"_posts/快速上手Docker.md","raw":"---\ntitle: 快速上手Docker\ntags: [docker, 教程]\n---\n\n![png1](../../image/docker.png)\n\n## Docker是什么？\n\nDocker主要是为了解决软件的运行环境问题，当然，主要是Linux软件，举一个简单的例子\n小明开发了一个网站，这个网站用到的技术包括Nginx，Python，MySQL，Redis，现在小明需要把这个网站部署上线，那么他至少要在一个服务器上做下面几件事\n1、在服务器上安装Nginx，Python，MySQL，Redis软件\n2、对机器和软件进行相关的配置设置，例如MySQL的端口号，Redis的端口号等\n3、把自己开发的网站代码打包，并且上传到服务器上，然后启动相关服务\n以上步骤是非常简化的版本，实际上如果真的要手动部署，可能会遇到更多问题\nDocker就是解决上面这些问题的，有了Docker，小明在任何一台服务器上部署自己的软件，只需要简单的一个命令\n\n``` shell\n$ docker run my-web-app\n```\n\nDocker会自动下载相关镜像，并且自动创建一个完全隔离的环境，然后运行相关的软件，这得益于LInux的底层隔离技术，包括Linux 命名空间、控制组和 UnionFS ，注意：Docker与虚拟机不同，虽然二者有点类似，但是Docker的隔离更轻量级，Docker并不是真正的虚拟机，Docker在底层是共享操作系统内核的，而虚拟机则不共享操作系统内核\n\n\n## 安装Docker\n\n\nLinux:\n\n``` shell\n$ curl -fsSL https://get.docker.com -o get-docker.sh\n$ sudo sh get-docker.sh\n```\n\n注意：如果安装了旧版本的Docker，需要使用对应的包管理工具卸载\n\nWindows 10 或 MacOS(不支持黑苹果)：\n[安装Docker Desktop](https://docs.docker.com/engine/install/)\n\n当然，如果是带UI的Linux发行版也可以安装Linux版本的Docker Desktop\n安装完成后在终端运行：\n\n``` shell\n$ docker version\n```\n如果看到版本信息则代表安装成功\n\n## Docker命令：\n\nDocker CLI的全量命令请参考:[这里](https://docs.docker.com/engine/reference/commandline/docker/)\n\n\n### 使用docker运行nginx\n\ndocker run可以直接运行一个容器，当本地不存在时，docker会从远端仓库拉取，默认的远端仓库是docker官方的docker hub，安装了Docker以后，基本上就不需要手动在服务器上安装任何软件了，假如你想运行一个nginx，那么你可以直接用下面的命令：\n\n``` shell\n$ docker run nginx\n```\n\n输出：\n``` shell\nUnable to find image 'nginx:latest' locally\nlatest: Pulling from library/nginx\na2abf6c4d29d: Pull complete\na9edb18cadd1: Pull complete\n589b7251471a: Pull complete\n186b1aaa4aa6: Pull complete\nb4df32aa5a72: Pull complete\na0bcbecc962e: Pull complete\nDigest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31\nStatus: Downloaded newer image for nginx:latest\n/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration\n/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh\n10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf\n10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh\n/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh\n/docker-entrypoint.sh: Configuration complete; ready for start up\n2022/06/26 02:59:53 [notice] 1#1: using the \"epoll\" event method\n2022/06/26 02:59:53 [notice] 1#1: nginx/1.21.5\n2022/06/26 02:59:53 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)\n2022/06/26 02:59:53 [notice] 1#1: OS: Linux 4.19.130-boot2docker\n2022/06/26 02:59:53 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576\n2022/06/26 02:59:53 [notice] 1#1: start worker processes\n2022/06/26 02:59:53 [notice] 1#1: start worker process 30\n```\n\n这样，nginx就直接运行起来了，但是默认没有在后台运行，当按下Ctrl+C软件就退出了，可以使用-d参数，让docker在后台运行该容器\n\n``` shell\n$ docker run -d nginx\n182214dcd10b23bba2559116d13171745550a5a52c745aa699a895edeb55b7d0\n```\n\ndocker 输出一串ID，nginx容器就在后台运行了，这个ID可以唯一标识一个容器，当需要输入这个ID时，大部分情况下并不需要输入完整的ID，输入前面几个字符就可以了\n使用docker ps 查看正在运行的容器\n``` shell\n$ docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES\n182214dcd10b   nginx     \"/docker-entrypoint.…\"   14 minutes ago   Up 14 minutes   80/tcp    cool_williams\n```\n\n可以看到正在运行的容器ID，使用的镜像，创建的时间还有端口号，名字等信息。\n使用 stop 命令停止容器\n``` shell\n$ docker stop 182214dcd10b\n$ 182214dcd10b\n```\n\n此时 docker ps无法查看该停止的容器\n``` shell\n$ docker ps\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n```\n\n使用 docker ps -a 可以查看所有状态的容器\n``` shell\n$ docker ps -a\nCONTAINER ID   IMAGE         COMMAND                  CREATED             STATUS                          PORTS     NAMES\n182214dcd10b   nginx         \"/docker-entrypoint.…\"   20 minutes ago      Exited (0) About a minute ago             cool_williams\n325b084cc16a   nginx         \"/docker-entrypoint.…\"   About an hour ago   Exited (0) 20 minutes ago                 priceless_cori\nc7e018e16d23   hello-world   \"/hello\"                 2 hours ago         Exited (0) 2 hours ago                    frosty_euclid\n```\n\n注意，此时无法通过外部的浏览器访问这个nginx服务器，因为docker内部的端口并没有暴露出来，可以运行下面的命令进行端口映射\n\n``` shell\n$ docker run -d -p 80:80 nginx\n```\n\n-p参数把docker内部的80端口映射到本机的80端口，打开浏览器，输入localhost就可以看到Nginx的欢迎页面了。\n-v参数可以挂载本地文件目录，一般在运行数据库容器时，需要将数据持久化，否则在容器退出后所有的数据将丢失；例如：\n\n``` shell\n$ docker run -d -p 80:80 -v /data/nginx:/data nginx\n```\n\n以上命令将本机的/data/nginx目录挂到到容器中的/data目录，如果容器中对/data目录的任何修改都将直接映射到外部磁盘上\ndocker exec命令可以在指定的容器内部执行命令，分为交互式和非交互式两种方式\n非交互式：\n``` shell\n$ docker exec 182214dcd10b ls -al /var\n```\n\nexec后面是docker id，然后紧跟要在容器中运行的命令\n交互式\n``` shell\n$ docker exec -it 182214dcd10b bash\n```\n\n-i选项代表使用交互方式，-t代表打开一个终端，bash是本次要运行的命令，一个shell程序\n这样就相当于打开了一个交互式终端进入了容器内部，所做的操作都只在容器内部生效，如同进入了一个虚拟机，使用exit命令来退出容器。\n\n## 使用DockerFile创建自己的容器\n\nDocker使用一种称为Dockerfile的文件来描述容器的组成以及相关配置，Dockerfile是docker的特有文件，必须满足相关格式\n假如要创建自己的web程序，需要将所有依赖都打包到一个镜像中，以某个操作系统为底座来构筑自己的镜像\n作为样例，我们使用python的flask框架来编写一个最简单的网页程序，并打包成一个镜像；关于flask可以参考如下[链接](https://flask.palletsprojects.com/en/2.1.x/)\n\n1、新建一个文件夹\n``` shell\nmkdir flask\n```\n\n2、打开一个py文件app.py，写入如下内容：\n``` python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello_world():\n    return \"<p>Hello, World!</p>\"\n\nif __name__ == \"__main__\":\n     app.run(host=\"0.0.0.0\", debug=True)\n```\n\n3、新建一个文件命名为dockerfile，写入如下内容：\n``` dockerfile\n#这是一个注释\nFROM ubuntu\n\nRUN apt-get update\nRUN apt-get install -y nginx\nRUN apt-get install -y python3\nRUN apt-get install -y python3-flask\nCOPY app.py /var/hello.py\nENV FLASK_APP=hello\nCMD cd /var && flask run\n```\n\ndockerfile其实只有一种格式，就是\n``` dockerfile\n# 注释\nINSTRUCTION arguments \n```\n\n一个命令然后紧跟参数\ndockerfile必须以FROM开始，代表在某个基础镜像上做接下来的操作，一般情况下以某个操作系统或某个现成的软件镜像开始；\n其他常用命令包括：\nRUN命令可以在镜像内部运行某个命令，本例中是使用apt-get命令来安装必要的软件\nCOPY命令可以将本地文件拷贝到容器内部，注意只能拷贝当前目录下的内容，因此COPY ../xxx xxx这种形式是无法成功的\nENV命令则可以简单的对容器注入环境变量\nCMD命令用于指定当容器运行时需要执行的默认命令，CMD命令可以被docker run命令覆盖，如果不希望被覆盖，可以考虑使用ENTRYPOINT\n全部的dockerfile手册请参考[官方文档](https://docs.docker.com/engine/reference/builder/#usage)\n\n之后就可以通过docker buid命令来构建镜像了\n4、运行：\n``` shell\n$ docker build -t flask:latest .\n```\n得到如下输出：\n``` shell\n[+] Building 0.2s (11/11) FINISHED\n => [internal] load build definition from Dockerfile                                                                                   0.0s\n => => transferring dockerfile: 248B                                                                                                   0.0s\n => [internal] load .dockerignore                                                                                                      0.0s\n => => transferring context: 2B                                                                                                        0.0s\n => [internal] load metadata for docker.io/library/ubuntu:latest                                                                       0.0s\n => [internal] load build context                                                                                                      0.0s\n => => transferring context: 27B                                                                                                       0.0s\n => [1/6] FROM docker.io/library/ubuntu                                                                                                0.0s\n => CACHED [2/6] RUN apt-get update                                                                                                    0.0s\n => CACHED [3/6] RUN apt-get install -y nginx                                                                                          0.0s\n => CACHED [4/6] RUN apt-get install -y python3                                                                                        0.0s\n => [6/6] COPY app.py /var/hello.py                                                                                                    0.0s\n => exporting to image                                                                                                                 0.0s\n => => writing image sha256:8ee4b660822edecb1bbe35f0421d57cfa94fe51533d16737e9ca0c84292fedf8                                           0.0s\n => => naming to docker.io/library/flask:latest                                                                                        0.0s\n ```\n-t 参数用于指明镜像的名称和tag，后面紧跟一个目录，docker会自动查找该目录下的dockerfile并根据该文件来进行镜像构建\n构建完成后可以使用docker image ls命令来查看当前机器上所有的镜像列表\n```  shell\n$ docker image ls\nREPOSITORY   TAG       IMAGE ID       CREATED         SIZE\nflask        latest    8ee4b660822e   5 seconds ago   213MB\n<none>       <none>    8b35a6e3e43d   7 minutes ago   213MB\nnginx        latest    605c77e624dd   6 months ago    141MB\nubuntu       latest    ba6acccedd29   8 months ago    72.8MB\n```\ndocker image命令是用来管理镜像的，使用方法可以通过:\n\n``` shell\n$ docker image --help\nUsage:  docker image COMMAND\n\nManage images\n\nCommands:\n  build       Build an image from a Dockerfile\n  history     Show the history of an image\n  import      Import the contents from a tarball to create a filesystem image\n  inspect     Display detailed information on one or more images\n  load        Load an image from a tar archive or STDIN\n  ls          List images\n  prune       Remove unused images\n  pull        Pull an image or a repository from a registry\n  push        Push an image or a repository to a registry\n  rm          Remove one or more images\n  save        Save one or more images to a tar archive (streamed to STDOUT by default)\n  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE\n```\n\n对于任意的docker命令都可以通过 docker COMMAND --help来查看使用方法。\n运行一下制作的镜像\n``` shell\n$ docker run flask\n * Serving Flask app \"hello\"\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n```\n至此，镜像已经成功制作并运行\n\n## Docker Registry 镜像仓库\n\ngit有github，docker也有docker hub，和git类似，docker需要一个存储所有镜像的地方，这样你可以和别人共享你制作的镜像，也可以使用别人制作的镜像，Docker官方提供的默认仓库是Docker hub，如果要修改默认的仓库可以运行：\n\n``` shell\nsudo vim /etc/docker/daemon.json\n```\n\n写入：\n``` json\n{\n  \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]\n}\n```\n列表中可以使用任何提供docker仓库服务的地址，上述例子中使用的是中科大的镜像仓库。\n接着，需要使配置生效：\n\n``` shell\nsudo systemctl daemon-reload \nsudo service docker restart \n```\n\n当然也可以使用本地仓库，使用本地仓库需要使用docker-registry，docker通过一个镜像提供了该服务，运行：\n\n``` shell\n$ docker run -d -p 5000:5000 --restart=always --name registry registry\n```\n默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /data/registry 目录。\n\n``` shell\n$ docker run -d  -p 5000:5000  -v /data/registry:/var/lib/registry registry\n```\n这样就运行了一个本地仓库并且镜像持久化的存储在/data/registry目录下。\n先尝试将本地的镜像推到仓库中：\n\n``` shell\n$ docker push 127.0.0.1:5000/ubuntu:latest\nThe push refers to repository [127.0.0.1:5000/ubuntu]\n373a30c24545: Pushed\na9148f5200b0: Pushed\ncdd3de0940ab: Pushed\nfc56279bbb33: Pushed\nb38367233d37: Pushed\n2aebd096e0e2: Pushed\nlatest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568\n```\n\n用 curl 查看仓库中的镜像。\n``` shell\n$ curl 127.0.0.1:5000/v2/_catalog\n{\"repositories\":[\"ubuntu\"]}\n```\n\n可以看到 {\"repositories\":[\"ubuntu\"]}，表明镜像已经被成功上传了。\n\n## Docker compose\n我们往往需要多个容器配合来完成某个上层应用，例如网站程序经常需要搭配一个数据库使用，这种情况可以把网站后台程序和数据库分别放到两个容器中运行，Docker compose工具提供一种简化的方式来组织多个容器，并且能够用一个命令快速的部署多个容器；\nDocker compose使用YAML文件来描述容器以及容器之间的关系，使用Docker compose一般分为3步\n- 定义每个容器的Dockerfile\n- 定义一个称为docker-compose.yaml的文件，用来描述多个容器之间的关系\n- 使用docker compose up命令一键部署应用程序\n我们仍然以上个例子中的flask程序为基础，并新增一个计数功能，为此我们需要改写我们的web程序，如下:\n\n``` python\nfrom flask import Flask\nfrom redis import Redis\n\napp = Flask(__name__)\nredis = Redis(host='redis', port=6379)\n\n@app.route('/')\ndef hello():\n     count = redis.incr('hits')\n     return '<p>Hello World! {} times。</p>'.format(count)\n\nif __name__ == \"__main__\":\n     app.run(host=\"0.0.0.0\", debug=True)\n```\n\n经过修改后，我们的程序会连接一个Redis数据库，并且每次被访问到，都会将计数加一，并展示到页面，为了连接Redis我们必须运行一个Redis的容器，好在该容器官方都制作好了，因此直接运行\n``` shell\n$ docker run -d redis\n```\n就可以直接运行一个Redis数据库，但是此时web程序并没有连接到这个Redis容器，我们需要定义两个容器的关系\n编写一个简单的docker-compose.yaml文件\n\n``` yaml\nservices:\n     web:\n         build: .\n         ports:\n             - \"5000:5000\"\n     redis:\n         image: \"redis:alpine\"\n```\n\ndocker-compose文件必须有一个services字段，每一个service可以理解为一个由多个容器组成的一个上层应用上述例子中的service由两个容器组成，名字分别是web、redis，其中web容器需要使用docker build命令来构筑镜像，使用的目录为当前目录，并且需要把端口5000映射到主机的5000端口\nredis容器责直接从系统配置的docker registry中尝试直接获取镜像\n运行\n\n``` shell\n$ docker compose up\n[+] Running 2/2\n - Container nginxpython-redis-1  Started                                                                0.3s\n - Container nginxpython-web-1    Started                                                                0.3s\n```\n\n此时两个容器就一并开始构建和启动起来了\n这里需要解释一个问题：为什么使用docker compose，flask程序就可以直接连接到一个名字为'redis'的主机上，他又是怎么找到这个主机的呢? 这与docker network的机制有关。\n\n## Docker network\n第一次安装完Docker，直接运行\n\n``` shell\n$ docker network ls\n```\n\n能够直接看到docker建立的默认网络，总共有3个\n\n``` shell\nNETWORK ID     NAME      DRIVER    SCOPE\n479bda8f37b9   bridge    bridge    local\n273213114bfe   host      host      local\ncce99c0034c4   none      null      local\n```\n\nbridge：docker 默认使用的是bridge，原理上是一个软件实现的二层交换机，如果不使用任何参数运行容器，那么默认会连接到bridge上，也就是说，默认一个机器上的容器都是可以互联互通的，但是这种情况下也只能通过IP来互联互通，无法通过hostname进行交互\nhost：移除容器和 Docker 宿主机之间的网络隔离，并直接使用主机的网络。host 模式仅适用于 Docker 17.06+\nnone：对于此容器，禁用所有联网。通常与自定义网络驱动程序一起使用。none 模式不适用于集群服务\n在Docker compose章节的例子中，flask程序是直接连接的一个名为'redis'的host，而容器本身并不知道redis这个host对应的ip地址是什么，所以无法连接\n如果要解决这个问题，我们可以手动修改flask程序的host文件，配置上redis容器的地址以及host，这样就可以互通了\n还有另外一种方法就是使用docker compose命令，如同上个章节那样，这种情况下，docker会默认建立一个自定义网络，而不是使用默认的bridge网络，此外，如果使用自定义网络，docker还会默认提供一个DNS服务器，用于一个services下的各个容器之间的域名解析，在运行完docker compose up后，可以查看docker network ls，会发现docker建立了一个网络，名称为nginxpython_default   \n```\n$ docker network ls\nNETWORK ID     NAME                  DRIVER    SCOPE\nadd5f8daed77   bridge                bridge    local\n3c065d8a1d64   host                  host      local\n41afd011cef9   nginxpython_default   bridge    local\nc31bc25f91ae   none                  null      local\n```\n此时，该docker compose定义的两个容器就能够通过镜像名称作为主机名称进行互联，且网络与其他容器是隔离的\ndocker 网络相关材料请参考[官方文档](https://docs.docker.com/network/)","slug":"快速上手Docker","published":1,"date":"2023-03-27T14:57:42.359Z","updated":"2023-04-15T10:01:31.237Z","_id":"clghsj4560000bwvi9unk7skx","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/../../image/docker.png\" alt=\"png1\"></p>\n<h2 id=\"Docker是什么？\"><a href=\"#Docker是什么？\" class=\"headerlink\" title=\"Docker是什么？\"></a>Docker是什么？</h2><p>Docker主要是为了解决软件的运行环境问题，当然，主要是Linux软件，举一个简单的例子<br>小明开发了一个网站，这个网站用到的技术包括Nginx，Python，MySQL，Redis，现在小明需要把这个网站部署上线，那么他至少要在一个服务器上做下面几件事<br>1、在服务器上安装Nginx，Python，MySQL，Redis软件<br>2、对机器和软件进行相关的配置设置，例如MySQL的端口号，Redis的端口号等<br>3、把自己开发的网站代码打包，并且上传到服务器上，然后启动相关服务<br>以上步骤是非常简化的版本，实际上如果真的要手动部署，可能会遇到更多问题<br>Docker就是解决上面这些问题的，有了Docker，小明在任何一台服务器上部署自己的软件，只需要简单的一个命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run my-web-app</span></span><br></pre></td></tr></table></figure>\n\n<p>Docker会自动下载相关镜像，并且自动创建一个完全隔离的环境，然后运行相关的软件，这得益于LInux的底层隔离技术，包括Linux 命名空间、控制组和 UnionFS ，注意：Docker与虚拟机不同，虽然二者有点类似，但是Docker的隔离更轻量级，Docker并不是真正的虚拟机，Docker在底层是共享操作系统内核的，而虚拟机则不共享操作系统内核</p>\n<h2 id=\"安装Docker\"><a href=\"#安装Docker\" class=\"headerlink\" title=\"安装Docker\"></a>安装Docker</h2><p>Linux:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">curl -fsSL https://get.docker.com -o get-docker.sh</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo sh get-docker.sh</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：如果安装了旧版本的Docker，需要使用对应的包管理工具卸载</p>\n<p>Windows 10 或 MacOS(不支持黑苹果)：<br><a href=\"https://docs.docker.com/engine/install/\">安装Docker Desktop</a></p>\n<p>当然，如果是带UI的Linux发行版也可以安装Linux版本的Docker Desktop<br>安装完成后在终端运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker version</span></span><br></pre></td></tr></table></figure>\n<p>如果看到版本信息则代表安装成功</p>\n<h2 id=\"Docker命令：\"><a href=\"#Docker命令：\" class=\"headerlink\" title=\"Docker命令：\"></a>Docker命令：</h2><p>Docker CLI的全量命令请参考:<a href=\"https://docs.docker.com/engine/reference/commandline/docker/\">这里</a></p>\n<h3 id=\"使用docker运行nginx\"><a href=\"#使用docker运行nginx\" class=\"headerlink\" title=\"使用docker运行nginx\"></a>使用docker运行nginx</h3><p>docker run可以直接运行一个容器，当本地不存在时，docker会从远端仓库拉取，默认的远端仓库是docker官方的docker hub，安装了Docker以后，基本上就不需要手动在服务器上安装任何软件了，假如你想运行一个nginx，那么你可以直接用下面的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unable to find image &#x27;nginx:latest&#x27; locally</span><br><span class=\"line\">latest: Pulling from library/nginx</span><br><span class=\"line\">a2abf6c4d29d: Pull complete</span><br><span class=\"line\">a9edb18cadd1: Pull complete</span><br><span class=\"line\">589b7251471a: Pull complete</span><br><span class=\"line\">186b1aaa4aa6: Pull complete</span><br><span class=\"line\">b4df32aa5a72: Pull complete</span><br><span class=\"line\">a0bcbecc962e: Pull complete</span><br><span class=\"line\">Digest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31</span><br><span class=\"line\">Status: Downloaded newer image for nginx:latest</span><br><span class=\"line\">/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration</span><br><span class=\"line\">/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/</span><br><span class=\"line\">/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh</span><br><span class=\"line\">10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf</span><br><span class=\"line\">10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf</span><br><span class=\"line\">/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh</span><br><span class=\"line\">/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh</span><br><span class=\"line\">/docker-entrypoint.sh: Configuration complete; ready for start up</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: using the &quot;epoll&quot; event method</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: nginx/1.21.5</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: OS: Linux 4.19.130-boot2docker</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: start worker processes</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: start worker process 30</span><br></pre></td></tr></table></figure>\n\n<p>这样，nginx就直接运行起来了，但是默认没有在后台运行，当按下Ctrl+C软件就退出了，可以使用-d参数，让docker在后台运行该容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d nginx</span></span><br><span class=\"line\">182214dcd10b23bba2559116d13171745550a5a52c745aa699a895edeb55b7d0</span><br></pre></td></tr></table></figure>\n\n<p>docker 输出一串ID，nginx容器就在后台运行了，这个ID可以唯一标识一个容器，当需要输入这个ID时，大部分情况下并不需要输入完整的ID，输入前面几个字符就可以了<br>使用docker ps 查看正在运行的容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker ps</span></span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class=\"line\">182214dcd10b   nginx     &quot;/docker-entrypoint.…&quot;   14 minutes ago   Up 14 minutes   80/tcp    cool_williams</span><br></pre></td></tr></table></figure>\n\n<p>可以看到正在运行的容器ID，使用的镜像，创建的时间还有端口号，名字等信息。<br>使用 stop 命令停止容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker stop 182214dcd10b</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">182214dcd10b</span></span><br></pre></td></tr></table></figure>\n\n<p>此时 docker ps无法查看该停止的容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker ps</span></span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure>\n\n<p>使用 docker ps -a 可以查看所有状态的容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker ps -a</span></span><br><span class=\"line\">CONTAINER ID   IMAGE         COMMAND                  CREATED             STATUS                          PORTS     NAMES</span><br><span class=\"line\">182214dcd10b   nginx         &quot;/docker-entrypoint.…&quot;   20 minutes ago      Exited (0) About a minute ago             cool_williams</span><br><span class=\"line\">325b084cc16a   nginx         &quot;/docker-entrypoint.…&quot;   About an hour ago   Exited (0) 20 minutes ago                 priceless_cori</span><br><span class=\"line\">c7e018e16d23   hello-world   &quot;/hello&quot;                 2 hours ago         Exited (0) 2 hours ago                    frosty_euclid</span><br></pre></td></tr></table></figure>\n\n<p>注意，此时无法通过外部的浏览器访问这个nginx服务器，因为docker内部的端口并没有暴露出来，可以运行下面的命令进行端口映射</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d -p 80:80 nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>-p参数把docker内部的80端口映射到本机的80端口，打开浏览器，输入localhost就可以看到Nginx的欢迎页面了。<br>-v参数可以挂载本地文件目录，一般在运行数据库容器时，需要将数据持久化，否则在容器退出后所有的数据将丢失；例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d -p 80:80 -v /data/nginx:/data nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令将本机的&#x2F;data&#x2F;nginx目录挂到到容器中的&#x2F;data目录，如果容器中对&#x2F;data目录的任何修改都将直接映射到外部磁盘上<br>docker exec命令可以在指定的容器内部执行命令，分为交互式和非交互式两种方式<br>非交互式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"built_in\">exec</span> 182214dcd10b <span class=\"built_in\">ls</span> -al /var</span></span><br></pre></td></tr></table></figure>\n\n<p>exec后面是docker id，然后紧跟要在容器中运行的命令<br>交互式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"built_in\">exec</span> -it 182214dcd10b bash</span></span><br></pre></td></tr></table></figure>\n\n<p>-i选项代表使用交互方式，-t代表打开一个终端，bash是本次要运行的命令，一个shell程序<br>这样就相当于打开了一个交互式终端进入了容器内部，所做的操作都只在容器内部生效，如同进入了一个虚拟机，使用exit命令来退出容器。</p>\n<h2 id=\"使用DockerFile创建自己的容器\"><a href=\"#使用DockerFile创建自己的容器\" class=\"headerlink\" title=\"使用DockerFile创建自己的容器\"></a>使用DockerFile创建自己的容器</h2><p>Docker使用一种称为Dockerfile的文件来描述容器的组成以及相关配置，Dockerfile是docker的特有文件，必须满足相关格式<br>假如要创建自己的web程序，需要将所有依赖都打包到一个镜像中，以某个操作系统为底座来构筑自己的镜像<br>作为样例，我们使用python的flask框架来编写一个最简单的网页程序，并打包成一个镜像；关于flask可以参考如下<a href=\"https://flask.palletsprojects.com/en/2.1.x/\">链接</a></p>\n<p>1、新建一个文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir flask</span><br></pre></td></tr></table></figure>\n\n<p>2、打开一个py文件app.py，写入如下内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&quot;/&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">hello_world</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">     app.run(host=<span class=\"string\">&quot;0.0.0.0&quot;</span>, debug=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>3、新建一个文件命名为dockerfile，写入如下内容：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#这是一个注释</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y nginx</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y python3</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y python3-flask</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> app.py /var/hello.py</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> FLASK_APP=hello</span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">cd</span> /var &amp;&amp; flask run</span></span><br></pre></td></tr></table></figure>\n\n<p>dockerfile其实只有一种格式，就是</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注释</span></span><br><span class=\"line\">INSTRUCTION arguments </span><br></pre></td></tr></table></figure>\n\n<p>一个命令然后紧跟参数<br>dockerfile必须以FROM开始，代表在某个基础镜像上做接下来的操作，一般情况下以某个操作系统或某个现成的软件镜像开始；<br>其他常用命令包括：<br>RUN命令可以在镜像内部运行某个命令，本例中是使用apt-get命令来安装必要的软件<br>COPY命令可以将本地文件拷贝到容器内部，注意只能拷贝当前目录下的内容，因此COPY ..&#x2F;xxx xxx这种形式是无法成功的<br>ENV命令则可以简单的对容器注入环境变量<br>CMD命令用于指定当容器运行时需要执行的默认命令，CMD命令可以被docker run命令覆盖，如果不希望被覆盖，可以考虑使用ENTRYPOINT<br>全部的dockerfile手册请参考<a href=\"https://docs.docker.com/engine/reference/builder/#usage\">官方文档</a></p>\n<p>之后就可以通过docker buid命令来构建镜像了<br>4、运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker build -t flask:latest .</span></span><br></pre></td></tr></table></figure>\n<p>得到如下输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[+] Building 0.2s (11/11) FINISHED</span><br><span class=\"line\"> =&gt; [internal] load build definition from Dockerfile                                                                                   0.0s</span><br><span class=\"line\"> =&gt; =&gt; transferring dockerfile: 248B                                                                                                   0.0s</span><br><span class=\"line\"> =&gt; [internal] load .dockerignore                                                                                                      0.0s</span><br><span class=\"line\"> =&gt; =&gt; transferring context: 2B                                                                                                        0.0s</span><br><span class=\"line\"> =&gt; [internal] load metadata for docker.io/library/ubuntu:latest                                                                       0.0s</span><br><span class=\"line\"> =&gt; [internal] load build context                                                                                                      0.0s</span><br><span class=\"line\"> =&gt; =&gt; transferring context: 27B                                                                                                       0.0s</span><br><span class=\"line\"> =&gt; [1/6] FROM docker.io/library/ubuntu                                                                                                0.0s</span><br><span class=\"line\"> =&gt; CACHED [2/6] RUN apt-get update                                                                                                    0.0s</span><br><span class=\"line\"> =&gt; CACHED [3/6] RUN apt-get install -y nginx                                                                                          0.0s</span><br><span class=\"line\"> =&gt; CACHED [4/6] RUN apt-get install -y python3                                                                                        0.0s</span><br><span class=\"line\"> =&gt; [6/6] COPY app.py /var/hello.py                                                                                                    0.0s</span><br><span class=\"line\"> =&gt; exporting to image                                                                                                                 0.0s</span><br><span class=\"line\"> =&gt; =&gt; writing image sha256:8ee4b660822edecb1bbe35f0421d57cfa94fe51533d16737e9ca0c84292fedf8                                           0.0s</span><br><span class=\"line\"> =&gt; =&gt; naming to docker.io/library/flask:latest                                                                                        0.0s</span><br></pre></td></tr></table></figure>\n<p>-t 参数用于指明镜像的名称和tag，后面紧跟一个目录，docker会自动查找该目录下的dockerfile并根据该文件来进行镜像构建<br>构建完成后可以使用docker image ls命令来查看当前机器上所有的镜像列表</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker image <span class=\"built_in\">ls</span></span></span><br><span class=\"line\">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class=\"line\">flask        latest    8ee4b660822e   5 seconds ago   213MB</span><br><span class=\"line\">&lt;none&gt;       &lt;none&gt;    8b35a6e3e43d   7 minutes ago   213MB</span><br><span class=\"line\">nginx        latest    605c77e624dd   6 months ago    141MB</span><br><span class=\"line\">ubuntu       latest    ba6acccedd29   8 months ago    72.8MB</span><br></pre></td></tr></table></figure>\n<p>docker image命令是用来管理镜像的，使用方法可以通过:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker image --<span class=\"built_in\">help</span></span></span><br><span class=\"line\">Usage:  docker image COMMAND</span><br><span class=\"line\"></span><br><span class=\"line\">Manage images</span><br><span class=\"line\"></span><br><span class=\"line\">Commands:</span><br><span class=\"line\">  build       Build an image from a Dockerfile</span><br><span class=\"line\">  history     Show the history of an image</span><br><span class=\"line\">  import      Import the contents from a tarball to create a filesystem image</span><br><span class=\"line\">  inspect     Display detailed information on one or more images</span><br><span class=\"line\">  load        Load an image from a tar archive or STDIN</span><br><span class=\"line\">  ls          List images</span><br><span class=\"line\">  prune       Remove unused images</span><br><span class=\"line\">  pull        Pull an image or a repository from a registry</span><br><span class=\"line\">  push        Push an image or a repository to a registry</span><br><span class=\"line\">  rm          Remove one or more images</span><br><span class=\"line\">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class=\"line\">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br></pre></td></tr></table></figure>\n\n<p>对于任意的docker命令都可以通过 docker COMMAND –help来查看使用方法。<br>运行一下制作的镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run flask</span></span><br><span class=\"line\"> * Serving Flask app &quot;hello&quot;</span><br><span class=\"line\"> * Environment: production</span><br><span class=\"line\">   WARNING: This is a development server. Do not use it in a production deployment.</span><br><span class=\"line\">   Use a production WSGI server instead.</span><br><span class=\"line\"> * Debug mode: off</span><br><span class=\"line\"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>\n<p>至此，镜像已经成功制作并运行</p>\n<h2 id=\"Docker-Registry-镜像仓库\"><a href=\"#Docker-Registry-镜像仓库\" class=\"headerlink\" title=\"Docker Registry 镜像仓库\"></a>Docker Registry 镜像仓库</h2><p>git有github，docker也有docker hub，和git类似，docker需要一个存储所有镜像的地方，这样你可以和别人共享你制作的镜像，也可以使用别人制作的镜像，Docker官方提供的默认仓库是Docker hub，如果要修改默认的仓库可以运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>\n\n<p>写入：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;registry-mirrors&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>列表中可以使用任何提供docker仓库服务的地址，上述例子中使用的是中科大的镜像仓库。<br>接着，需要使配置生效：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl daemon-reload </span><br><span class=\"line\">sudo service docker restart </span><br></pre></td></tr></table></figure>\n\n<p>当然也可以使用本地仓库，使用本地仓库需要使用docker-registry，docker通过一个镜像提供了该服务，运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d -p 5000:5000 --restart=always --name registry registry</span></span><br></pre></td></tr></table></figure>\n<p>默认情况下，仓库会被创建在容器的 &#x2F;var&#x2F;lib&#x2F;registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 &#x2F;data&#x2F;registry 目录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d  -p 5000:5000  -v /data/registry:/var/lib/registry registry</span></span><br></pre></td></tr></table></figure>\n<p>这样就运行了一个本地仓库并且镜像持久化的存储在&#x2F;data&#x2F;registry目录下。<br>先尝试将本地的镜像推到仓库中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker push 127.0.0.1:5000/ubuntu:latest</span></span><br><span class=\"line\">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class=\"line\">373a30c24545: Pushed</span><br><span class=\"line\">a9148f5200b0: Pushed</span><br><span class=\"line\">cdd3de0940ab: Pushed</span><br><span class=\"line\">fc56279bbb33: Pushed</span><br><span class=\"line\">b38367233d37: Pushed</span><br><span class=\"line\">2aebd096e0e2: Pushed</span><br><span class=\"line\">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure>\n\n<p>用 curl 查看仓库中的镜像。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">curl 127.0.0.1:5000/v2/_catalog</span></span><br><span class=\"line\">&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 {“repositories”:[“ubuntu”]}，表明镜像已经被成功上传了。</p>\n<h2 id=\"Docker-compose\"><a href=\"#Docker-compose\" class=\"headerlink\" title=\"Docker compose\"></a>Docker compose</h2><p>我们往往需要多个容器配合来完成某个上层应用，例如网站程序经常需要搭配一个数据库使用，这种情况可以把网站后台程序和数据库分别放到两个容器中运行，Docker compose工具提供一种简化的方式来组织多个容器，并且能够用一个命令快速的部署多个容器；<br>Docker compose使用YAML文件来描述容器以及容器之间的关系，使用Docker compose一般分为3步</p>\n<ul>\n<li>定义每个容器的Dockerfile</li>\n<li>定义一个称为docker-compose.yaml的文件，用来描述多个容器之间的关系</li>\n<li>使用docker compose up命令一键部署应用程序<br>我们仍然以上个例子中的flask程序为基础，并新增一个计数功能，为此我们需要改写我们的web程序，如下:</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> redis <span class=\"keyword\">import</span> Redis</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">redis = Redis(host=<span class=\"string\">&#x27;redis&#x27;</span>, port=<span class=\"number\">6379</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">hello</span>():</span><br><span class=\"line\">     count = redis.incr(<span class=\"string\">&#x27;hits&#x27;</span>)</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&lt;p&gt;Hello World! &#123;&#125; times。&lt;/p&gt;&#x27;</span>.<span class=\"built_in\">format</span>(count)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">     app.run(host=<span class=\"string\">&quot;0.0.0.0&quot;</span>, debug=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>经过修改后，我们的程序会连接一个Redis数据库，并且每次被访问到，都会将计数加一，并展示到页面，为了连接Redis我们必须运行一个Redis的容器，好在该容器官方都制作好了，因此直接运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d redis</span></span><br></pre></td></tr></table></figure>\n<p>就可以直接运行一个Redis数据库，但是此时web程序并没有连接到这个Redis容器，我们需要定义两个容器的关系<br>编写一个简单的docker-compose.yaml文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">     <span class=\"attr\">web:</span></span><br><span class=\"line\">         <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">         <span class=\"attr\">ports:</span></span><br><span class=\"line\">             <span class=\"bullet\">-</span> <span class=\"string\">&quot;5000:5000&quot;</span></span><br><span class=\"line\">     <span class=\"attr\">redis:</span></span><br><span class=\"line\">         <span class=\"attr\">image:</span> <span class=\"string\">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>docker-compose文件必须有一个services字段，每一个service可以理解为一个由多个容器组成的一个上层应用上述例子中的service由两个容器组成，名字分别是web、redis，其中web容器需要使用docker build命令来构筑镜像，使用的目录为当前目录，并且需要把端口5000映射到主机的5000端口<br>redis容器责直接从系统配置的docker registry中尝试直接获取镜像<br>运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker compose up</span></span><br><span class=\"line\">[+] Running 2/2</span><br><span class=\"line\"> - Container nginxpython-redis-1  Started                                                                0.3s</span><br><span class=\"line\"> - Container nginxpython-web-1    Started                                                                0.3s</span><br></pre></td></tr></table></figure>\n\n<p>此时两个容器就一并开始构建和启动起来了<br>这里需要解释一个问题：为什么使用docker compose，flask程序就可以直接连接到一个名字为’redis’的主机上，他又是怎么找到这个主机的呢? 这与docker network的机制有关。</p>\n<h2 id=\"Docker-network\"><a href=\"#Docker-network\" class=\"headerlink\" title=\"Docker network\"></a>Docker network</h2><p>第一次安装完Docker，直接运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker network <span class=\"built_in\">ls</span></span></span><br></pre></td></tr></table></figure>\n\n<p>能够直接看到docker建立的默认网络，总共有3个</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class=\"line\">479bda8f37b9   bridge    bridge    local</span><br><span class=\"line\">273213114bfe   host      host      local</span><br><span class=\"line\">cce99c0034c4   none      null      local</span><br></pre></td></tr></table></figure>\n\n<p>bridge：docker 默认使用的是bridge，原理上是一个软件实现的二层交换机，如果不使用任何参数运行容器，那么默认会连接到bridge上，也就是说，默认一个机器上的容器都是可以互联互通的，但是这种情况下也只能通过IP来互联互通，无法通过hostname进行交互<br>host：移除容器和 Docker 宿主机之间的网络隔离，并直接使用主机的网络。host 模式仅适用于 Docker 17.06+<br>none：对于此容器，禁用所有联网。通常与自定义网络驱动程序一起使用。none 模式不适用于集群服务<br>在Docker compose章节的例子中，flask程序是直接连接的一个名为’redis’的host，而容器本身并不知道redis这个host对应的ip地址是什么，所以无法连接<br>如果要解决这个问题，我们可以手动修改flask程序的host文件，配置上redis容器的地址以及host，这样就可以互通了<br>还有另外一种方法就是使用docker compose命令，如同上个章节那样，这种情况下，docker会默认建立一个自定义网络，而不是使用默认的bridge网络，此外，如果使用自定义网络，docker还会默认提供一个DNS服务器，用于一个services下的各个容器之间的域名解析，在运行完docker compose up后，可以查看docker network ls，会发现docker建立了一个网络，名称为nginxpython_default   </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker network ls</span><br><span class=\"line\">NETWORK ID     NAME                  DRIVER    <span class=\"keyword\">SCOPE</span></span><br><span class=\"line\">add5f8daed77   bridge                bridge    <span class=\"keyword\">local</span></span><br><span class=\"line\"><span class=\"number\">3</span>c065d8a1d64   host                  host      <span class=\"keyword\">local</span></span><br><span class=\"line\"><span class=\"number\">41</span>afd011cef9   nginxpython_default   bridge    <span class=\"keyword\">local</span></span><br><span class=\"line\">c31bc25f91ae   <span class=\"keyword\">none</span>                  <span class=\"keyword\">null</span>      <span class=\"keyword\">local</span></span><br></pre></td></tr></table></figure>\n<p>此时，该docker compose定义的两个容器就能够通过镜像名称作为主机名称进行互联，且网络与其他容器是隔离的<br>docker 网络相关材料请参考<a href=\"https://docs.docker.com/network/\">官方文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/../../image/docker.png\" alt=\"png1\"></p>\n<h2 id=\"Docker是什么？\"><a href=\"#Docker是什么？\" class=\"headerlink\" title=\"Docker是什么？\"></a>Docker是什么？</h2><p>Docker主要是为了解决软件的运行环境问题，当然，主要是Linux软件，举一个简单的例子<br>小明开发了一个网站，这个网站用到的技术包括Nginx，Python，MySQL，Redis，现在小明需要把这个网站部署上线，那么他至少要在一个服务器上做下面几件事<br>1、在服务器上安装Nginx，Python，MySQL，Redis软件<br>2、对机器和软件进行相关的配置设置，例如MySQL的端口号，Redis的端口号等<br>3、把自己开发的网站代码打包，并且上传到服务器上，然后启动相关服务<br>以上步骤是非常简化的版本，实际上如果真的要手动部署，可能会遇到更多问题<br>Docker就是解决上面这些问题的，有了Docker，小明在任何一台服务器上部署自己的软件，只需要简单的一个命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run my-web-app</span></span><br></pre></td></tr></table></figure>\n\n<p>Docker会自动下载相关镜像，并且自动创建一个完全隔离的环境，然后运行相关的软件，这得益于LInux的底层隔离技术，包括Linux 命名空间、控制组和 UnionFS ，注意：Docker与虚拟机不同，虽然二者有点类似，但是Docker的隔离更轻量级，Docker并不是真正的虚拟机，Docker在底层是共享操作系统内核的，而虚拟机则不共享操作系统内核</p>\n<h2 id=\"安装Docker\"><a href=\"#安装Docker\" class=\"headerlink\" title=\"安装Docker\"></a>安装Docker</h2><p>Linux:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">curl -fsSL https://get.docker.com -o get-docker.sh</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo sh get-docker.sh</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：如果安装了旧版本的Docker，需要使用对应的包管理工具卸载</p>\n<p>Windows 10 或 MacOS(不支持黑苹果)：<br><a href=\"https://docs.docker.com/engine/install/\">安装Docker Desktop</a></p>\n<p>当然，如果是带UI的Linux发行版也可以安装Linux版本的Docker Desktop<br>安装完成后在终端运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker version</span></span><br></pre></td></tr></table></figure>\n<p>如果看到版本信息则代表安装成功</p>\n<h2 id=\"Docker命令：\"><a href=\"#Docker命令：\" class=\"headerlink\" title=\"Docker命令：\"></a>Docker命令：</h2><p>Docker CLI的全量命令请参考:<a href=\"https://docs.docker.com/engine/reference/commandline/docker/\">这里</a></p>\n<h3 id=\"使用docker运行nginx\"><a href=\"#使用docker运行nginx\" class=\"headerlink\" title=\"使用docker运行nginx\"></a>使用docker运行nginx</h3><p>docker run可以直接运行一个容器，当本地不存在时，docker会从远端仓库拉取，默认的远端仓库是docker官方的docker hub，安装了Docker以后，基本上就不需要手动在服务器上安装任何软件了，假如你想运行一个nginx，那么你可以直接用下面的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unable to find image &#x27;nginx:latest&#x27; locally</span><br><span class=\"line\">latest: Pulling from library/nginx</span><br><span class=\"line\">a2abf6c4d29d: Pull complete</span><br><span class=\"line\">a9edb18cadd1: Pull complete</span><br><span class=\"line\">589b7251471a: Pull complete</span><br><span class=\"line\">186b1aaa4aa6: Pull complete</span><br><span class=\"line\">b4df32aa5a72: Pull complete</span><br><span class=\"line\">a0bcbecc962e: Pull complete</span><br><span class=\"line\">Digest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31</span><br><span class=\"line\">Status: Downloaded newer image for nginx:latest</span><br><span class=\"line\">/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration</span><br><span class=\"line\">/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/</span><br><span class=\"line\">/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh</span><br><span class=\"line\">10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf</span><br><span class=\"line\">10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf</span><br><span class=\"line\">/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh</span><br><span class=\"line\">/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh</span><br><span class=\"line\">/docker-entrypoint.sh: Configuration complete; ready for start up</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: using the &quot;epoll&quot; event method</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: nginx/1.21.5</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: OS: Linux 4.19.130-boot2docker</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: start worker processes</span><br><span class=\"line\">2022/06/26 02:59:53 [notice] 1#1: start worker process 30</span><br></pre></td></tr></table></figure>\n\n<p>这样，nginx就直接运行起来了，但是默认没有在后台运行，当按下Ctrl+C软件就退出了，可以使用-d参数，让docker在后台运行该容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d nginx</span></span><br><span class=\"line\">182214dcd10b23bba2559116d13171745550a5a52c745aa699a895edeb55b7d0</span><br></pre></td></tr></table></figure>\n\n<p>docker 输出一串ID，nginx容器就在后台运行了，这个ID可以唯一标识一个容器，当需要输入这个ID时，大部分情况下并不需要输入完整的ID，输入前面几个字符就可以了<br>使用docker ps 查看正在运行的容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker ps</span></span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class=\"line\">182214dcd10b   nginx     &quot;/docker-entrypoint.…&quot;   14 minutes ago   Up 14 minutes   80/tcp    cool_williams</span><br></pre></td></tr></table></figure>\n\n<p>可以看到正在运行的容器ID，使用的镜像，创建的时间还有端口号，名字等信息。<br>使用 stop 命令停止容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker stop 182214dcd10b</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">182214dcd10b</span></span><br></pre></td></tr></table></figure>\n\n<p>此时 docker ps无法查看该停止的容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker ps</span></span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure>\n\n<p>使用 docker ps -a 可以查看所有状态的容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker ps -a</span></span><br><span class=\"line\">CONTAINER ID   IMAGE         COMMAND                  CREATED             STATUS                          PORTS     NAMES</span><br><span class=\"line\">182214dcd10b   nginx         &quot;/docker-entrypoint.…&quot;   20 minutes ago      Exited (0) About a minute ago             cool_williams</span><br><span class=\"line\">325b084cc16a   nginx         &quot;/docker-entrypoint.…&quot;   About an hour ago   Exited (0) 20 minutes ago                 priceless_cori</span><br><span class=\"line\">c7e018e16d23   hello-world   &quot;/hello&quot;                 2 hours ago         Exited (0) 2 hours ago                    frosty_euclid</span><br></pre></td></tr></table></figure>\n\n<p>注意，此时无法通过外部的浏览器访问这个nginx服务器，因为docker内部的端口并没有暴露出来，可以运行下面的命令进行端口映射</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d -p 80:80 nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>-p参数把docker内部的80端口映射到本机的80端口，打开浏览器，输入localhost就可以看到Nginx的欢迎页面了。<br>-v参数可以挂载本地文件目录，一般在运行数据库容器时，需要将数据持久化，否则在容器退出后所有的数据将丢失；例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d -p 80:80 -v /data/nginx:/data nginx</span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令将本机的&#x2F;data&#x2F;nginx目录挂到到容器中的&#x2F;data目录，如果容器中对&#x2F;data目录的任何修改都将直接映射到外部磁盘上<br>docker exec命令可以在指定的容器内部执行命令，分为交互式和非交互式两种方式<br>非交互式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"built_in\">exec</span> 182214dcd10b <span class=\"built_in\">ls</span> -al /var</span></span><br></pre></td></tr></table></figure>\n\n<p>exec后面是docker id，然后紧跟要在容器中运行的命令<br>交互式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker <span class=\"built_in\">exec</span> -it 182214dcd10b bash</span></span><br></pre></td></tr></table></figure>\n\n<p>-i选项代表使用交互方式，-t代表打开一个终端，bash是本次要运行的命令，一个shell程序<br>这样就相当于打开了一个交互式终端进入了容器内部，所做的操作都只在容器内部生效，如同进入了一个虚拟机，使用exit命令来退出容器。</p>\n<h2 id=\"使用DockerFile创建自己的容器\"><a href=\"#使用DockerFile创建自己的容器\" class=\"headerlink\" title=\"使用DockerFile创建自己的容器\"></a>使用DockerFile创建自己的容器</h2><p>Docker使用一种称为Dockerfile的文件来描述容器的组成以及相关配置，Dockerfile是docker的特有文件，必须满足相关格式<br>假如要创建自己的web程序，需要将所有依赖都打包到一个镜像中，以某个操作系统为底座来构筑自己的镜像<br>作为样例，我们使用python的flask框架来编写一个最简单的网页程序，并打包成一个镜像；关于flask可以参考如下<a href=\"https://flask.palletsprojects.com/en/2.1.x/\">链接</a></p>\n<p>1、新建一个文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir flask</span><br></pre></td></tr></table></figure>\n\n<p>2、打开一个py文件app.py，写入如下内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&quot;/&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">hello_world</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">     app.run(host=<span class=\"string\">&quot;0.0.0.0&quot;</span>, debug=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>3、新建一个文件命名为dockerfile，写入如下内容：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#这是一个注释</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y nginx</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y python3</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y python3-flask</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> app.py /var/hello.py</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> FLASK_APP=hello</span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">cd</span> /var &amp;&amp; flask run</span></span><br></pre></td></tr></table></figure>\n\n<p>dockerfile其实只有一种格式，就是</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注释</span></span><br><span class=\"line\">INSTRUCTION arguments </span><br></pre></td></tr></table></figure>\n\n<p>一个命令然后紧跟参数<br>dockerfile必须以FROM开始，代表在某个基础镜像上做接下来的操作，一般情况下以某个操作系统或某个现成的软件镜像开始；<br>其他常用命令包括：<br>RUN命令可以在镜像内部运行某个命令，本例中是使用apt-get命令来安装必要的软件<br>COPY命令可以将本地文件拷贝到容器内部，注意只能拷贝当前目录下的内容，因此COPY ..&#x2F;xxx xxx这种形式是无法成功的<br>ENV命令则可以简单的对容器注入环境变量<br>CMD命令用于指定当容器运行时需要执行的默认命令，CMD命令可以被docker run命令覆盖，如果不希望被覆盖，可以考虑使用ENTRYPOINT<br>全部的dockerfile手册请参考<a href=\"https://docs.docker.com/engine/reference/builder/#usage\">官方文档</a></p>\n<p>之后就可以通过docker buid命令来构建镜像了<br>4、运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker build -t flask:latest .</span></span><br></pre></td></tr></table></figure>\n<p>得到如下输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[+] Building 0.2s (11/11) FINISHED</span><br><span class=\"line\"> =&gt; [internal] load build definition from Dockerfile                                                                                   0.0s</span><br><span class=\"line\"> =&gt; =&gt; transferring dockerfile: 248B                                                                                                   0.0s</span><br><span class=\"line\"> =&gt; [internal] load .dockerignore                                                                                                      0.0s</span><br><span class=\"line\"> =&gt; =&gt; transferring context: 2B                                                                                                        0.0s</span><br><span class=\"line\"> =&gt; [internal] load metadata for docker.io/library/ubuntu:latest                                                                       0.0s</span><br><span class=\"line\"> =&gt; [internal] load build context                                                                                                      0.0s</span><br><span class=\"line\"> =&gt; =&gt; transferring context: 27B                                                                                                       0.0s</span><br><span class=\"line\"> =&gt; [1/6] FROM docker.io/library/ubuntu                                                                                                0.0s</span><br><span class=\"line\"> =&gt; CACHED [2/6] RUN apt-get update                                                                                                    0.0s</span><br><span class=\"line\"> =&gt; CACHED [3/6] RUN apt-get install -y nginx                                                                                          0.0s</span><br><span class=\"line\"> =&gt; CACHED [4/6] RUN apt-get install -y python3                                                                                        0.0s</span><br><span class=\"line\"> =&gt; [6/6] COPY app.py /var/hello.py                                                                                                    0.0s</span><br><span class=\"line\"> =&gt; exporting to image                                                                                                                 0.0s</span><br><span class=\"line\"> =&gt; =&gt; writing image sha256:8ee4b660822edecb1bbe35f0421d57cfa94fe51533d16737e9ca0c84292fedf8                                           0.0s</span><br><span class=\"line\"> =&gt; =&gt; naming to docker.io/library/flask:latest                                                                                        0.0s</span><br></pre></td></tr></table></figure>\n<p>-t 参数用于指明镜像的名称和tag，后面紧跟一个目录，docker会自动查找该目录下的dockerfile并根据该文件来进行镜像构建<br>构建完成后可以使用docker image ls命令来查看当前机器上所有的镜像列表</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker image <span class=\"built_in\">ls</span></span></span><br><span class=\"line\">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class=\"line\">flask        latest    8ee4b660822e   5 seconds ago   213MB</span><br><span class=\"line\">&lt;none&gt;       &lt;none&gt;    8b35a6e3e43d   7 minutes ago   213MB</span><br><span class=\"line\">nginx        latest    605c77e624dd   6 months ago    141MB</span><br><span class=\"line\">ubuntu       latest    ba6acccedd29   8 months ago    72.8MB</span><br></pre></td></tr></table></figure>\n<p>docker image命令是用来管理镜像的，使用方法可以通过:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker image --<span class=\"built_in\">help</span></span></span><br><span class=\"line\">Usage:  docker image COMMAND</span><br><span class=\"line\"></span><br><span class=\"line\">Manage images</span><br><span class=\"line\"></span><br><span class=\"line\">Commands:</span><br><span class=\"line\">  build       Build an image from a Dockerfile</span><br><span class=\"line\">  history     Show the history of an image</span><br><span class=\"line\">  import      Import the contents from a tarball to create a filesystem image</span><br><span class=\"line\">  inspect     Display detailed information on one or more images</span><br><span class=\"line\">  load        Load an image from a tar archive or STDIN</span><br><span class=\"line\">  ls          List images</span><br><span class=\"line\">  prune       Remove unused images</span><br><span class=\"line\">  pull        Pull an image or a repository from a registry</span><br><span class=\"line\">  push        Push an image or a repository to a registry</span><br><span class=\"line\">  rm          Remove one or more images</span><br><span class=\"line\">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class=\"line\">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br></pre></td></tr></table></figure>\n\n<p>对于任意的docker命令都可以通过 docker COMMAND –help来查看使用方法。<br>运行一下制作的镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run flask</span></span><br><span class=\"line\"> * Serving Flask app &quot;hello&quot;</span><br><span class=\"line\"> * Environment: production</span><br><span class=\"line\">   WARNING: This is a development server. Do not use it in a production deployment.</span><br><span class=\"line\">   Use a production WSGI server instead.</span><br><span class=\"line\"> * Debug mode: off</span><br><span class=\"line\"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>\n<p>至此，镜像已经成功制作并运行</p>\n<h2 id=\"Docker-Registry-镜像仓库\"><a href=\"#Docker-Registry-镜像仓库\" class=\"headerlink\" title=\"Docker Registry 镜像仓库\"></a>Docker Registry 镜像仓库</h2><p>git有github，docker也有docker hub，和git类似，docker需要一个存储所有镜像的地方，这样你可以和别人共享你制作的镜像，也可以使用别人制作的镜像，Docker官方提供的默认仓库是Docker hub，如果要修改默认的仓库可以运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>\n\n<p>写入：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;registry-mirrors&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>列表中可以使用任何提供docker仓库服务的地址，上述例子中使用的是中科大的镜像仓库。<br>接着，需要使配置生效：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl daemon-reload </span><br><span class=\"line\">sudo service docker restart </span><br></pre></td></tr></table></figure>\n\n<p>当然也可以使用本地仓库，使用本地仓库需要使用docker-registry，docker通过一个镜像提供了该服务，运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d -p 5000:5000 --restart=always --name registry registry</span></span><br></pre></td></tr></table></figure>\n<p>默认情况下，仓库会被创建在容器的 &#x2F;var&#x2F;lib&#x2F;registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 &#x2F;data&#x2F;registry 目录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d  -p 5000:5000  -v /data/registry:/var/lib/registry registry</span></span><br></pre></td></tr></table></figure>\n<p>这样就运行了一个本地仓库并且镜像持久化的存储在&#x2F;data&#x2F;registry目录下。<br>先尝试将本地的镜像推到仓库中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker push 127.0.0.1:5000/ubuntu:latest</span></span><br><span class=\"line\">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class=\"line\">373a30c24545: Pushed</span><br><span class=\"line\">a9148f5200b0: Pushed</span><br><span class=\"line\">cdd3de0940ab: Pushed</span><br><span class=\"line\">fc56279bbb33: Pushed</span><br><span class=\"line\">b38367233d37: Pushed</span><br><span class=\"line\">2aebd096e0e2: Pushed</span><br><span class=\"line\">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure>\n\n<p>用 curl 查看仓库中的镜像。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">curl 127.0.0.1:5000/v2/_catalog</span></span><br><span class=\"line\">&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 {“repositories”:[“ubuntu”]}，表明镜像已经被成功上传了。</p>\n<h2 id=\"Docker-compose\"><a href=\"#Docker-compose\" class=\"headerlink\" title=\"Docker compose\"></a>Docker compose</h2><p>我们往往需要多个容器配合来完成某个上层应用，例如网站程序经常需要搭配一个数据库使用，这种情况可以把网站后台程序和数据库分别放到两个容器中运行，Docker compose工具提供一种简化的方式来组织多个容器，并且能够用一个命令快速的部署多个容器；<br>Docker compose使用YAML文件来描述容器以及容器之间的关系，使用Docker compose一般分为3步</p>\n<ul>\n<li>定义每个容器的Dockerfile</li>\n<li>定义一个称为docker-compose.yaml的文件，用来描述多个容器之间的关系</li>\n<li>使用docker compose up命令一键部署应用程序<br>我们仍然以上个例子中的flask程序为基础，并新增一个计数功能，为此我们需要改写我们的web程序，如下:</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> redis <span class=\"keyword\">import</span> Redis</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">redis = Redis(host=<span class=\"string\">&#x27;redis&#x27;</span>, port=<span class=\"number\">6379</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">hello</span>():</span><br><span class=\"line\">     count = redis.incr(<span class=\"string\">&#x27;hits&#x27;</span>)</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&lt;p&gt;Hello World! &#123;&#125; times。&lt;/p&gt;&#x27;</span>.<span class=\"built_in\">format</span>(count)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">     app.run(host=<span class=\"string\">&quot;0.0.0.0&quot;</span>, debug=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>经过修改后，我们的程序会连接一个Redis数据库，并且每次被访问到，都会将计数加一，并展示到页面，为了连接Redis我们必须运行一个Redis的容器，好在该容器官方都制作好了，因此直接运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker run -d redis</span></span><br></pre></td></tr></table></figure>\n<p>就可以直接运行一个Redis数据库，但是此时web程序并没有连接到这个Redis容器，我们需要定义两个容器的关系<br>编写一个简单的docker-compose.yaml文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">     <span class=\"attr\">web:</span></span><br><span class=\"line\">         <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">         <span class=\"attr\">ports:</span></span><br><span class=\"line\">             <span class=\"bullet\">-</span> <span class=\"string\">&quot;5000:5000&quot;</span></span><br><span class=\"line\">     <span class=\"attr\">redis:</span></span><br><span class=\"line\">         <span class=\"attr\">image:</span> <span class=\"string\">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>docker-compose文件必须有一个services字段，每一个service可以理解为一个由多个容器组成的一个上层应用上述例子中的service由两个容器组成，名字分别是web、redis，其中web容器需要使用docker build命令来构筑镜像，使用的目录为当前目录，并且需要把端口5000映射到主机的5000端口<br>redis容器责直接从系统配置的docker registry中尝试直接获取镜像<br>运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker compose up</span></span><br><span class=\"line\">[+] Running 2/2</span><br><span class=\"line\"> - Container nginxpython-redis-1  Started                                                                0.3s</span><br><span class=\"line\"> - Container nginxpython-web-1    Started                                                                0.3s</span><br></pre></td></tr></table></figure>\n\n<p>此时两个容器就一并开始构建和启动起来了<br>这里需要解释一个问题：为什么使用docker compose，flask程序就可以直接连接到一个名字为’redis’的主机上，他又是怎么找到这个主机的呢? 这与docker network的机制有关。</p>\n<h2 id=\"Docker-network\"><a href=\"#Docker-network\" class=\"headerlink\" title=\"Docker network\"></a>Docker network</h2><p>第一次安装完Docker，直接运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker network <span class=\"built_in\">ls</span></span></span><br></pre></td></tr></table></figure>\n\n<p>能够直接看到docker建立的默认网络，总共有3个</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class=\"line\">479bda8f37b9   bridge    bridge    local</span><br><span class=\"line\">273213114bfe   host      host      local</span><br><span class=\"line\">cce99c0034c4   none      null      local</span><br></pre></td></tr></table></figure>\n\n<p>bridge：docker 默认使用的是bridge，原理上是一个软件实现的二层交换机，如果不使用任何参数运行容器，那么默认会连接到bridge上，也就是说，默认一个机器上的容器都是可以互联互通的，但是这种情况下也只能通过IP来互联互通，无法通过hostname进行交互<br>host：移除容器和 Docker 宿主机之间的网络隔离，并直接使用主机的网络。host 模式仅适用于 Docker 17.06+<br>none：对于此容器，禁用所有联网。通常与自定义网络驱动程序一起使用。none 模式不适用于集群服务<br>在Docker compose章节的例子中，flask程序是直接连接的一个名为’redis’的host，而容器本身并不知道redis这个host对应的ip地址是什么，所以无法连接<br>如果要解决这个问题，我们可以手动修改flask程序的host文件，配置上redis容器的地址以及host，这样就可以互通了<br>还有另外一种方法就是使用docker compose命令，如同上个章节那样，这种情况下，docker会默认建立一个自定义网络，而不是使用默认的bridge网络，此外，如果使用自定义网络，docker还会默认提供一个DNS服务器，用于一个services下的各个容器之间的域名解析，在运行完docker compose up后，可以查看docker network ls，会发现docker建立了一个网络，名称为nginxpython_default   </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker network ls</span><br><span class=\"line\">NETWORK ID     NAME                  DRIVER    <span class=\"keyword\">SCOPE</span></span><br><span class=\"line\">add5f8daed77   bridge                bridge    <span class=\"keyword\">local</span></span><br><span class=\"line\"><span class=\"number\">3</span>c065d8a1d64   host                  host      <span class=\"keyword\">local</span></span><br><span class=\"line\"><span class=\"number\">41</span>afd011cef9   nginxpython_default   bridge    <span class=\"keyword\">local</span></span><br><span class=\"line\">c31bc25f91ae   <span class=\"keyword\">none</span>                  <span class=\"keyword\">null</span>      <span class=\"keyword\">local</span></span><br></pre></td></tr></table></figure>\n<p>此时，该docker compose定义的两个容器就能够通过镜像名称作为主机名称进行互联，且网络与其他容器是隔离的<br>docker 网络相关材料请参考<a href=\"https://docs.docker.com/network/\">官方文档</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clghs86jx0000sgvifk67gdwu","tag_id":"clghs86k20002sgvibuhogf19","_id":"clghs86k60006sgvi0wuf9cwb"},{"post_id":"clghs86k10001sgvifqd67ypx","tag_id":"clghs86k60005sgvia9pybqh0","_id":"clghs86k8000bsgvie7or1198"},{"post_id":"clghs86k10001sgvifqd67ypx","tag_id":"clghs86k80009sgvihya5d2qe","_id":"clghs86k8000csgvi1tay7j5w"},{"post_id":"clghs86k40003sgvi57u2hzx2","tag_id":"clghs86k8000asgvi09no7koz","_id":"clghs86k9000fsgvi1wjr15xb"},{"post_id":"clghs86k40003sgvi57u2hzx2","tag_id":"clghs86k9000dsgvi815e4h0g","_id":"clghs86k9000gsgvigkpqgbmv"},{"post_id":"clghs86k50004sgvi8lhs2ryg","tag_id":"clghs86k9000esgviaul802p8","_id":"clghs86k9000isgvi9b2jaymz"},{"post_id":"clghs86k60007sgvi85ys6ets","tag_id":"clghs86k9000hsgvie2dr8tl0","_id":"clghs86ka000ksgvienk59cp6"},{"post_id":"clghs86k70008sgvi0bu6gzr0","tag_id":"clghs86ka000jsgvih5oh491b","_id":"clghs86ka000msgvi5r4s9n3i"},{"post_id":"clghs86k70008sgvi0bu6gzr0","tag_id":"clghs86ka000lsgvi4eks3fq5","_id":"clghs86ka000nsgvib442g9tu"},{"post_id":"clghsj4560000bwvi9unk7skx","tag_id":"clghszc270002l0vigqv1gu6m","_id":"clghszc280004l0vi3iit2z6l"},{"post_id":"clghsj4560000bwvi9unk7skx","tag_id":"clghszc280003l0vi15qib3ax","_id":"clghszc280005l0vigzbr0xk1"}],"Tag":[{"name":"流水账","_id":"clghs86k20002sgvibuhogf19"},{"name":"Raft","_id":"clghs86k60005sgvia9pybqh0"},{"name":"分布式","_id":"clghs86k80009sgvihya5d2qe"},{"name":"exit","_id":"clghs86k8000asgvi09no7koz"},{"name":"僵尸进程","_id":"clghs86k9000dsgvi815e4h0g"},{"name":"CAP Theorem","_id":"clghs86k9000esgviaul802p8"},{"name":"动态链接库","_id":"clghs86k9000hsgvie2dr8tl0"},{"name":"线程","_id":"clghs86ka000jsgvih5oh491b"},{"name":"重入","_id":"clghs86ka000lsgvi4eks3fq5"},{"name":"docker","_id":"clghszc270002l0vigqv1gu6m"},{"name":"教程","_id":"clghszc280003l0vi15qib3ax"}]}}